<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Math4ML</title>
    <link href="/2024/02/07/Math4ML/"/>
    <url>/2024/02/07/Math4ML/</url>
    
    <content type="html"><![CDATA[<p><a href="https://myblackboxrecorder.com/use-math-in-hexo/">数学公式支持</a></p><h2 id="Probability-and-Distribution"><a href="#Probability-and-Distribution" class="headerlink" title="Probability and Distribution"></a>Probability and Distribution</h2><h3 id="Discrete-and-Continuous-Probabilitie"><a href="#Discrete-and-Continuous-Probabilitie" class="headerlink" title="Discrete and Continuous Probabilitie"></a>Discrete and Continuous Probabilitie</h3><p><strong>quantity of interest</strong>:some characteristic of the distribution of a population random variable.</p><p>Posterior $p(\mathbf{x|y})$ is quantity of interest in Bayesian statjstics. i.e., know aboout $\mathbf{x}$ after having observed $\mathbf{y}$</p><p>quantity</p><script type="math/tex; mode=display">p(\mathbf{y})\colon= \int p(\mathbf{y|x})p(\mathbf{x})dx = \mathbb{E_x}[p\mathbf{(y|x)}]</script>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>paper_read</title>
    <link href="/2024/01/25/paper-read/"/>
    <url>/2024/01/25/paper-read/</url>
    
    <content type="html"><![CDATA[<p><strong>NOTE</strong>: <a href="https://www.notion.so/PAPER-0ce3b7d6f7444da8b386f33d21b0afe8?pvs=4">调试数学公式恼羞成怒调整至notion中完成</a></p><h1 id="paper-read"><a href="#paper-read" class="headerlink" title="paper_read"></a>paper_read</h1><p><a href="https://gitee.com/ZhangYi_ustc/torch_learn">学习代码</a></p><p>$help$</p><h2 id="TODO-list"><a href="#TODO-list" class="headerlink" title="TODO list"></a>TODO list</h2><ul><li>[x] Prompting Large Language Models for Recommender Systems: A Comprehensive Framework and Empirical Analysis</li><li>[x]  LlamaRec: Two-Stage Recommendation using Large Language Models for Ranking</li><li>[x]  Adapting Large Language Models by Integrating Collaborative Semantics for Recommendation</li><li>[x]  Toolformer: Language Models Can Teach Themselves to Use Tools</li><li>[x]  clip</li><li>[x]  dalle2</li><li>[x] Generative Modeling by Estimating Gradients of the Data Distribution</li></ul><h2 id="Generative-model"><a href="#Generative-model" class="headerlink" title="Generative model"></a>Generative model</h2><h3 id="Generative-Modeling-by-Estimating-Gradients-of-the-Data-Distribution"><a href="#Generative-Modeling-by-Estimating-Gradients-of-the-Data-Distribution" class="headerlink" title="Generative Modeling by Estimating Gradients of the Data Distribution"></a><a href="https://zhuanlan.zhihu.com/p/656417979">Generative Modeling by Estimating Gradients of the Data Distribution</a></h3><p><a href="https://www.bilibili.com/video/BV1Do4y16767/?spm_id_from=333.337.search-card.all.click&amp;vd_source=6299aeae8989a203c110117bfebb54f7">video</a><br>score 为数据的对数概率密度增长最快的方向</p><script type="math/tex; mode=display">\mathbf{S\theta(x)}= \nabla_x\log_{p_\theta} (x)</script><!-- ![梯度场](https://vdn3.vzuu.com/SD/83349034-5927-11ed-a869-76a40522aa1e.mp4?disable_local_cache=1&bu=078babd7&c=avc.1.1&f=mp4&expiration=1707227005&auth_key=1707227005-0-0-54dcd8af71d3cb2bc33cf3cc8fb9e478&v=tx&pu=078babd7) --><p>朗之万采样:从先验分布中随机采样一个初始样本，然后利用score逐渐将样本像数据分布的高概率密度区域靠近，同时为了生成结果的多样性，需要采用过程带有随机性。同时z服从正态分布，epsilon为每次移动的步长</p><script type="math/tex; mode=display">\bold{x}_{i+1} \rightarrow \bold{x}_i + \epsilon\nabla_x\log p(x)+\sqrt{2\epsilon}\bold{z_i}</script><h4 id="Denoising-Score-Matching"><a href="#Denoising-Score-Matching" class="headerlink" title="Denoising Score Matching"></a>Denoising Score Matching</h4><script type="math/tex; mode=display">q_\sigma(\tilde{x}|x)\thicksim N(\tilde{x};x,\sigma^2I)</script><h2 id="rec-amp-amp-llm"><a href="#rec-amp-amp-llm" class="headerlink" title="rec &amp;&amp; llm"></a>rec &amp;&amp; llm</h2><h3 id="Prompting-Large-Language-Models-for-Recommender-Systems-A-Comprehensive-Framework-and-Empirical-Analysis"><a href="#Prompting-Large-Language-Models-for-Recommender-Systems-A-Comprehensive-Framework-and-Empirical-Analysis" class="headerlink" title="Prompting Large Language Models for Recommender Systems: A Comprehensive Framework and Empirical Analysis"></a>Prompting Large Language Models for Recommender Systems: A Comprehensive Framework and Empirical Analysis</h3><ul><li>[ ] code</li></ul><h4 id="some-finding"><a href="#some-finding" class="headerlink" title="some finding"></a>some finding</h4><ul><li>Fine-tuning all parameters of LLMs for recommendation is more effective than parameter-efficient fine-tuning, but more training time is required</li><li>Increasing the number of historical items to represent users brings insignificant gains for LLM</li></ul><h4 id="problem"><a href="#problem" class="headerlink" title="problem"></a>problem</h4><ul><li>Existing literature has also found the position bias in LLM-based recommendations [32, 74, 133], and methods such as bootstrapping [32] and Bayesian probability framework [74] havebeen proposed to calibrate unstable results. However, the instability of LLMs is still an unresolved issue.</li></ul><h3 id="Adapting-Large-Language-Models-by-Integrating-Collaborative-Semantics-for-Recommendation"><a href="#Adapting-Large-Language-Models-by-Integrating-Collaborative-Semantics-for-Recommendation" class="headerlink" title="Adapting Large Language Models by Integrating Collaborative Semantics for Recommendation"></a>Adapting Large Language Models by Integrating Collaborative Semantics for Recommendation</h3><p><img src="../paper-read/2step.png" alt=""></p><h4 id="idea"><a href="#idea" class="headerlink" title="idea"></a>idea</h4><p>recinterpret + llara</p><h4 id="motivation"><a href="#motivation" class="headerlink" title="motivation"></a>motivation</h4><p>integrate language and collaborative semantics for recommender systems<br>Our approach can directly generate items from the<br>entire item set for recommendation, without relying on candidate items.</p><h4 id="method"><a href="#method" class="headerlink" title="method"></a>method</h4><ol><li>item indexing<ol><li>These item indices are learned based on the text embeddings of items encoded by LLMs, enabling the learned IDs to capture the intrinsic similarity among items</li><li>按照语义相关度，分割成树状的id</li></ol></li><li>finetune<ol><li>多种推荐任务的文本描述finetune</li></ol></li></ol><h3 id="LlamaRec-Two-Stage-Recommendation-using-Large-Language-Models-for-Ranking"><a href="#LlamaRec-Two-Stage-Recommendation-using-Large-Language-Models-for-Ranking" class="headerlink" title="LlamaRec: Two-Stage Recommendation using Large Language Models for Ranking"></a>LlamaRec: Two-Stage Recommendation using Large Language Models for Ranking</h3><ul><li>[x] code 抽象类，数据处理加载 ，llama的logits运用</li></ul><p><img src="../paper-read/llamarec.png" alt=""></p><h4 id="idea-1"><a href="#idea-1" class="headerlink" title="idea"></a>idea</h4><p>升级版本tallrec,tallrec的候选list的延伸,通过logits+softmax的形式来进行重新排序，但是训练的方式同alpaca，但是用了pytorch-lighting的形式。</p><h4 id="motivation-召回-排序"><a href="#motivation-召回-排序" class="headerlink" title="motivation 召回 排序"></a>motivation 召回 排序</h4><ol><li>序列推荐召回list</li><li>设计了 verbalizer approach，用计算logits的方式作为打分依据，解决了推理时延问题</li><li>分词的方式是item逐一处理再进行拼接。</li></ol><h4 id="novelty"><a href="#novelty" class="headerlink" title="novelty"></a>novelty</h4><p>method</p><h2 id="llm"><a href="#llm" class="headerlink" title="llm"></a>llm</h2><h3 id="Toolformer-Language-Models-Can-Teach-Themselves-to-Use-Tools"><a href="#Toolformer-Language-Models-Can-Teach-Themselves-to-Use-Tools" class="headerlink" title="Toolformer: Language Models Can Teach Themselves to Use Tools"></a>Toolformer: Language Models Can Teach Themselves to Use Tools</h3><p><img src="../paper-read/toolformer.png" alt=""></p><ul><li>[x] code: 正则表达式</li></ul><h4 id="idea-2"><a href="#idea-2" class="headerlink" title="idea"></a>idea</h4><p>无监督的方式教会语言模型使用工具</p><h4 id="motivation-1"><a href="#motivation-1" class="headerlink" title="motivation"></a>motivation</h4><p>相当于多遍扫描的过程，第一遍text插入在哪使用工具，第二遍通过替换工具的内容，通过loss函数的计算决定是否替换，然后用finetune的手段进行生成。</p><h4 id="method-1"><a href="#method-1" class="headerlink" title="method"></a>method</h4><ol><li>添加在哪里使用工具</li><li>调用工具，同时计算loss，设置阀值决定是否需要替换。</li></ol><h2 id="vision-amp-amp-LLM"><a href="#vision-amp-amp-LLM" class="headerlink" title="vision &amp;&amp; LLM"></a>vision &amp;&amp; LLM</h2><h3 id="CLIP"><a href="#CLIP" class="headerlink" title="CLIP"></a>CLIP</h3><p><img src="../paper-read/CLIP.png" alt="CLIP"></p><h4 id="idea-3"><a href="#idea-3" class="headerlink" title="idea"></a>idea</h4><p>our intuition is that CLIP models will need to learn to recognize a wide variety of visual concepts in images and associate them with their names</p><h4 id="method-2"><a href="#method-2" class="headerlink" title="method"></a>method</h4><p>通过正负样本对进行训练,样本对通过编码器，然后同时对batch中多对样本进行点积处理，然后可以分出正负的样本对</p><p><img src="../paper-read/Contrast_CLIP.png" alt="clip-contrast"></p><h3 id="diffusion"><a href="#diffusion" class="headerlink" title="diffusion"></a>diffusion</h3><p>把picture作为视频的id，然后用文本进行生成，然后用生成的picture作为检索的策略？</p><ol><li>文字LLM增大，encoder 成对资料更好，但是diffusion model扩大效果不好</li><li>FID 评估指标 small is better<br><img src="../paper-read/FID.png" alt="FID"></li></ol><h3 id="NLP-diffusion"><a href="#NLP-diffusion" class="headerlink" title="NLP-diffusion"></a>NLP-diffusion</h3><p>通过token转换成embedding上面添加noise，再进行还原</p><ul><li>[ ] to be done</li></ul><p><img src="../paper-read/NLP-diffusion.png" alt="NLP"></p><p><img src="../paper-read/NLP-diffusion2.png" alt="NLP2"></p><h3 id="stable-diffusion"><a href="#stable-diffusion" class="headerlink" title="stable diffusion"></a>stable diffusion</h3><h4 id="decode"><a href="#decode" class="headerlink" title="decode"></a>decode</h4><p><img src="../paper-read/Decoder-SD.png" alt="decode"></p><h2 id="ablity"><a href="#ablity" class="headerlink" title="ablity"></a>ablity</h2><ul><li>[x] <a href="https://lilianweng.github.io/posts/2023-01-27-the-transformer-family-v2/">transformer-famlily</a></li></ul><h2 id="application"><a href="#application" class="headerlink" title="application"></a>application</h2><ol><li>adaptive attendsion span </li><li><strong>class-free guidance</strong></li></ol><p>week </p><ol><li>transformer相关模型与blog</li><li>探究多模态推荐，主要学习diffusion模型，并复原了diffusion（DDPM）的代码。然后阅读的论文有clip（文本段和图片的对比学习），dalle2（unclip模型）。这两篇工作都强调了增大数据规模后，性能获得了大幅提升，（不确定diffusion+rec是否可行局限于rec数据集和CV数据集的差异，以及rec的数据量是离散的，之后计划阅读两者结合后的论文diffurec，以及打算阅读NLP上的diffusion应用和class-free guidance论文）</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>blog</title>
    <link href="/2023/12/06/blog/"/>
    <url>/2023/12/06/blog/</url>
    
    <content type="html"><![CDATA[<p>我不会说p5全是bug，但这是事实。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>web</title>
    <link href="/2023/10/23/web/"/>
    <url>/2023/10/23/web/</url>
    
    <content type="html"><![CDATA[<h3 id="检索"><a href="#检索" class="headerlink" title="检索"></a>检索</h3><h4 id="预训练模型"><a href="#预训练模型" class="headerlink" title="预训练模型"></a>预训练模型</h4><p>大规模的数据和模型,学习语料库的知识,将这些知识迁移到某一个具体的任务中,从而获得较好的表现<br><strong>transforms</strong></p><ul><li>基于位置信息表征,适应较长的文本</li><li>优势:矩阵乘法为核心,GPU高速运算</li><li><img src="/web/%E6%88%AA%E5%B1%8F.png"></li><li>bert:过绕诶家发双向多层,position + Token + segment信息embedding<ul><li>预训练 随机mask部分词,然后用上下</li><li>fine-tune:<ul><li>选择训练好的最后一层,分类层进行替换,冻结先前的部分,</li><li>利用新的分类层的反相传递优化过层</li></ul></li></ul></li><li>缺点,安全问题,以及</li><li>优点:<ul><li>任务难度大 采用上游预训练,下游微调的范式.</li><li>充分利用了大量的无标签数据,开放世界的知识应用于下游任务,从而大幅度提高了模型效果</li><li>可以直接使用</li></ul></li></ul><h2 id="协同过滤"><a href="#协同过滤" class="headerlink" title="协同过滤"></a>协同过滤</h2><p><img src="/web/%E6%88%AA%E5%B1%8F%201.png"></p><p><img src="/web/%E6%88%AA%E5%B1%8F%202.png"></p><h3 id="item"><a href="#item" class="headerlink" title="item"></a>item</h3><p><img src="/web/%E6%88%AA%E5%B1%8F%203.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>pytorch</title>
    <link href="/2023/10/19/torch/"/>
    <url>/2023/10/19/torch/</url>
    
    <content type="html"><![CDATA[<h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">is_valid_string</span>(<span class="hljs-params">s</span>):<br>    <span class="hljs-keyword">return</span> exists(re.fullmatch(<span class="hljs-string">r&quot;&#x27;[^&#x27;]*&#x27;|\&quot;[^\&quot;]*\&quot;&quot;</span>, s))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">is_valid_integer</span>(<span class="hljs-params">s</span>):<br>    <span class="hljs-keyword">return</span> exists(re.fullmatch(<span class="hljs-string">r&quot;[+-]?\d+&quot;</span>, s))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">is_valid_float</span>(<span class="hljs-params">s</span>):<br>    <span class="hljs-keyword">return</span> exists(re.fullmatch(<span class="hljs-string">r&quot;[+-]?\d+(\.\d+)?&quot;</span>, s))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">parse_param</span>(<span class="hljs-params">s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-type">Optional</span>[<span class="hljs-type">Union</span>[<span class="hljs-built_in">int</span>, <span class="hljs-built_in">float</span>, <span class="hljs-built_in">str</span>]]:<br>    <span class="hljs-keyword">if</span> is_valid_string(s):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>(s)<br>    <span class="hljs-keyword">elif</span> is_valid_integer(s):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(s)<br>    <span class="hljs-keyword">elif</span> is_valid_float(s):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">float</span>(s)<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br>params = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> s: s.strip(), params)) <span class="hljs-comment"># 去处list的字符，同时重建</span><br><br>params = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">filter</span>(<span class="hljs-built_in">len</span>, params))<span class="hljs-comment"># filter 接受一个函数和一个迭代器，然后通过过滤参数中的不符合条件的</span><br></code></pre></td></tr></table></figure><h3 id="transformer"><a href="#transformer" class="headerlink" title="transformer"></a>transformer</h3><h4 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><br>torch.topk(logits, k)<span class="hljs-comment"># return val and indice of logits of the topk</span><br><br>torch.full_like(logits, -torch.finfo(logits.dtype).<span class="hljs-built_in">max</span>) <span class="hljs-comment"># make a tensor shape like logits ,and value is B</span><br></code></pre></td></tr></table></figure><h4 id="embedding"><a href="#embedding" class="headerlink" title="embedding"></a>embedding</h4><p>GitHub Copilot: <code>nn.Embedding</code> 是 PyTorch 中的一个类，用于创建一个嵌入层。嵌入层可以将离散的类别变量（如单词）映射到连续的向量空间。</p><p>在你的代码中，<code>nn.Embedding(n_src_vocab, d_word_vec, padding_idx=pad_idx)</code> 这行代码创建了一个嵌入层，其参数如下：</p><ul><li><code>n_src_vocab</code>：嵌入层的输入维度，即源词汇表的大小。</li><li><code>d_word_vec</code>：嵌入层的输出维度，即词向量的维度。</li><li><code>padding_idx</code>：如果提供了这个参数，那么对应索引的嵌入向量会被初始化为零。这通常用于表示填充（padding）的标记。</li></ul><p>所以，这个嵌入层可以将一个形状为 <code>(batch_size, seq_len)</code> 的整数张量（每个整数都是一个单词的索引）转换为一个形状为 <code>(batch_size, seq_len, d_word_vec)</code> 的浮点张量（每个浮点向量都是一个单词的嵌入）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">torch.arange()<br>torch.mat<br><span class="hljs-built_in">filter</span>(func,iterable) <span class="hljs-comment">#按照func，排除不符合条件的值。</span><br>user, items = line.strip().split(<span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-number">1</span>)<span class="hljs-comment">#取第一个</span><br>nn.embedding(a,b,)<br>adj = sp.coo_matrix((vals, (rows, cols)), shape=(self.n_users_entities, self.n_users_entities)) <span class="hljs-comment"># 通过制定行与列，val放置了相关的标签。 rows cols里面防止了相关的关系</span><br></code></pre></td></tr></table></figure><p>在class 中init其他的类，也能创建类似的方法</p><h3 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">linear = torch.nn.Linear(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)<br>batch = tensor[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>]<br>linear(batch)<br></code></pre></td></tr></table></figure><p>以上的作用形式为对于每一个batch,作用称4*3 * 3*4的矩阵形式</p><h3 id="torch-optimizer"><a href="#torch-optimizer" class="headerlink" title="torch.optimizer"></a>torch.optimizer</h3><h4 id="优化器在实现"><a href="#优化器在实现" class="headerlink" title="优化器在实现"></a>优化器在实现</h4><ol><li>优化方向</li><li>优化步长</li></ol><p>更新步骤</p><ol><li>计算当前函数关于每一个函数的梯度</li><li>根据历史梯度计算一阶动量和二阶动量</li><li>计算当前时刻的下降梯度</li><li>依据下降梯度更新参数</li></ol><h5 id="SGD"><a href="#SGD" class="headerlink" title="SGD"></a>SGD</h5><p>随机梯度下降：直接更新一个样本点</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>spyter</title>
    <link href="/2023/10/08/spyter/"/>
    <url>/2023/10/08/spyter/</url>
    
    <content type="html"><![CDATA[<h2 id="BeautifulSoup"><a href="#BeautifulSoup" class="headerlink" title="BeautifulSoup"></a>BeautifulSoup</h2><h3 id="use"><a href="#use" class="headerlink" title="use"></a>use</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># soup 分词之后,soup.p为下面的标题的内容</span><br></code></pre></td></tr></table></figure><p>如果需要寻找多条相同的标签下的内容 可以通过</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">a_tag  = soup.find_all(<span class="hljs-string">&#x27;a&#x27;</span>)<span class="hljs-comment">#作为找到这个分割下面的</span><br><br>soup = BeautifulSoup(<span class="hljs-string">&#x27;&lt;b class=&quot;boldest&quot;&gt;Extremely bold&lt;/b&gt;&#x27;</span>, <span class="hljs-string">&#x27;lxml)</span><br><span class="hljs-string">soup.b.name#表示tag的name</span><br><span class="hljs-string">soup.attrs[&quot;name&quot;]#可以选择name的属性标签</span><br><span class="hljs-string">soup.string#也是可以获取文本内容</span><br><span class="hljs-string">soup.p.contents #用于指示两者之间的内容</span><br><span class="hljs-string">soup.p.children #可以展现里面所有的标签</span><br><span class="hljs-string">parents # as same function</span><br><span class="hljs-string"></span><br></code></pre></td></tr></table></figure><h3 id="子节点"><a href="#子节点" class="headerlink" title="子节点"></a>子节点</h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>prompt-engineer</title>
    <link href="/2023/10/07/prompt-engineer/"/>
    <url>/2023/10/07/prompt-engineer/</url>
    
    <content type="html"><![CDATA[<h1 id="Prompt-Engineering-for-Developer"><a href="#Prompt-Engineering-for-Developer" class="headerlink" title="Prompt Engineering for Developer"></a>Prompt Engineering for Developer</h1><h2 id="Guideline"><a href="#Guideline" class="headerlink" title="Guideline"></a>Guideline</h2><h3 id="编写清晰、具体的指令"><a href="#编写清晰、具体的指令" class="headerlink" title="编写清晰、具体的指令"></a>编写清晰、具体的指令</h3><h4 id="分隔符"><a href="#分隔符" class="headerlink" title="分隔符"></a>分隔符</h4><p>“””，&lt; &gt;，<tag> </tag>之类的作为,防止Prompt Rejection</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> tool <span class="hljs-keyword">import</span> get_completion<br><br>text = <span class="hljs-string">f&quot;&quot;&quot;</span><br><span class="hljs-string">您应该提供尽可能清晰、具体的指示，以表达您希望模型执行的任务。\</span><br><span class="hljs-string">这将引导模型朝向所需的输出，并降低收到无关或不正确响应的可能性。\</span><br><span class="hljs-string">不要将写清晰的提示词与写简短的提示词混淆。\</span><br><span class="hljs-string">在许多情况下，更长的提示词可以为模型提供更多的清晰度和上下文信息，从而导致更详细和相关的输出。</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-comment"># 需要总结的文本内容</span><br>prompt = <span class="hljs-string">f&quot;&quot;&quot;</span><br><span class="hljs-string">把用三个反引号括起来的文本总结成一句话。</span><br><span class="hljs-string">```<span class="hljs-subst">&#123;text&#125;</span>```</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-comment"># 指令内容，使用 ``` 来分隔指令和待总结的内容</span><br>response = get_completion(prompt)<br><span class="hljs-built_in">print</span>(response)<br><span class="hljs-comment"># \ 作为分割符,同时可以指示生成的文档</span><br>prompt = <span class="hljs-string">f&quot;&quot;&quot;</span><br><span class="hljs-string">请生成包括书名、作者和类别的三本虚构的、非真实存在的中文书籍清单，\</span><br><span class="hljs-string">并以 JSON 格式提供，其中包含以下键:book_id、title、author、genre。</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>response = get_completion(prompt)<br><span class="hljs-built_in">print</span>(response)<br><br><br></code></pre></td></tr></table></figure><h4 id="检查模型是否满足条件"><a href="#检查模型是否满足条件" class="headerlink" title="检查模型是否满足条件"></a>检查模型是否满足条件</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 满足条件的输入（text中提供了步骤）</span><br>text_1 = <span class="hljs-string">f&quot;&quot;&quot;</span><br><span class="hljs-string">泡一杯茶很容易。首先，需要把水烧开。\</span><br><span class="hljs-string">在等待期间，拿一个杯子并把茶包放进去。\</span><br><span class="hljs-string">一旦水足够热，就把它倒在茶包上。\</span><br><span class="hljs-string">等待一会儿，让茶叶浸泡。几分钟后，取出茶包。\</span><br><span class="hljs-string">如果您愿意，可以加一些糖或牛奶调味。\</span><br><span class="hljs-string">就这样，您可以享受一杯美味的茶了。</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>prompt = <span class="hljs-string">f&quot;&quot;&quot;</span><br><span class="hljs-string">您将获得由三个引号括起来的文本。\</span><br><span class="hljs-string">如果它包含一系列的指令，则需要按照以下格式重新编写这些指令：</span><br><span class="hljs-string"></span><br><span class="hljs-string">第一步 - ...</span><br><span class="hljs-string">第二步 - …</span><br><span class="hljs-string">…</span><br><span class="hljs-string">第N步 - …</span><br><span class="hljs-string"></span><br><span class="hljs-string">如果文本中不包含一系列的指令，则直接写“未提供步骤”。&quot;</span><br><span class="hljs-string">\&quot;\&quot;\&quot;<span class="hljs-subst">&#123;text_1&#125;</span>\&quot;\&quot;\&quot;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>response = get_completion(prompt)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Text 1 的总结:&quot;</span>)<br><span class="hljs-built_in">print</span>(response)<br></code></pre></td></tr></table></figure><h4 id="提供少量示例"><a href="#提供少量示例" class="headerlink" title="提供少量示例"></a>提供少量示例</h4><p>给模型一两个已经完成的用例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">prompt = <span class="hljs-string">f&quot;&quot;&quot;</span><br><span class="hljs-string">您的任务是以一致的风格回答问题。</span><br><span class="hljs-string"></span><br><span class="hljs-string">&lt;孩子&gt;: 请教我何为耐心。</span><br><span class="hljs-string"></span><br><span class="hljs-string">&lt;祖父母&gt;: 挖出最深峡谷的河流源于一处不起眼的泉眼；最宏伟的交响乐从单一的音符开始；最复杂的挂毯以一根孤独的线开始编织。</span><br><span class="hljs-string"></span><br><span class="hljs-string">&lt;孩子&gt;: 请教我何为韧性。</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>response = get_completion(prompt)<br><span class="hljs-built_in">print</span>(response)<br></code></pre></td></tr></table></figure><h3 id="给模型时间思考"><a href="#给模型时间思考" class="headerlink" title="给模型时间思考"></a>给模型时间思考</h3><h4 id="指定完成任务所需要的步骤"><a href="#指定完成任务所需要的步骤" class="headerlink" title="指定完成任务所需要的步骤"></a>指定完成任务所需要的步骤</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python">text = <span class="hljs-string">f&quot;&quot;&quot;</span><br><span class="hljs-string">在一个迷人的村庄里，兄妹杰克和吉尔出发去一个山顶井里打水。\</span><br><span class="hljs-string">他们一边唱着欢乐的歌，一边往上爬，\</span><br><span class="hljs-string">然而不幸降临——杰克绊了一块石头，从山上滚了下来，吉尔紧随其后。\</span><br><span class="hljs-string">虽然略有些摔伤，但他们还是回到了温馨的家中。\</span><br><span class="hljs-string">尽管出了这样的意外，他们的冒险精神依然没有减弱，继续充满愉悦地探索。</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-comment"># example 1</span><br>prompt_1 = <span class="hljs-string">f&quot;&quot;&quot;</span><br><span class="hljs-string">执行以下操作：</span><br><span class="hljs-string">1-用一句话概括下面用三个反引号括起来的文本。</span><br><span class="hljs-string">2-将摘要翻译成英语。</span><br><span class="hljs-string">3-在英语摘要中列出每个人名。</span><br><span class="hljs-string">4-输出一个 JSON 对象，其中包含以下键：english_summary，num_names。</span><br><span class="hljs-string"></span><br><span class="hljs-string">请用换行符分隔您的答案。</span><br><span class="hljs-string"></span><br><span class="hljs-string">Text:</span><br><span class="hljs-string">```<span class="hljs-subst">&#123;text&#125;</span>```</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>response = get_completion(prompt_1)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;prompt 1:&quot;</span>)<br><span class="hljs-built_in">print</span>(response)<br><br>prompt_2 = <span class="hljs-string">f&quot;&quot;&quot;</span><br><span class="hljs-string">1-用一句话概括下面用&lt;&gt;括起来的文本。</span><br><span class="hljs-string">2-将摘要翻译成英语。</span><br><span class="hljs-string">3-在英语摘要中列出每个名称。</span><br><span class="hljs-string">4-输出一个 JSON 对象，其中包含以下键：English_summary，num_names。</span><br><span class="hljs-string"></span><br><span class="hljs-string">请使用以下格式：</span><br><span class="hljs-string">文本：&lt;要总结的文本&gt;</span><br><span class="hljs-string">摘要：&lt;摘要&gt;</span><br><span class="hljs-string">翻译：&lt;摘要的翻译&gt;</span><br><span class="hljs-string">名称：&lt;英语摘要中的名称列表&gt;</span><br><span class="hljs-string">输出 JSON：&lt;带有 English_summary 和 num_names 的 JSON&gt;</span><br><span class="hljs-string"></span><br><span class="hljs-string">Text: &lt;<span class="hljs-subst">&#123;text&#125;</span>&gt;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>response = get_completion(prompt_2)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\nprompt 2:&quot;</span>)<br><span class="hljs-built_in">print</span>(response)<br><br></code></pre></td></tr></table></figure><h4 id="指导模型在下结论之前找到一个自己的解法"><a href="#指导模型在下结论之前找到一个自己的解法" class="headerlink" title="指导模型在下结论之前找到一个自己的解法"></a>指导模型在下结论之前找到一个自己的解法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python">prompt = <span class="hljs-string">f&quot;&quot;&quot;</span><br><span class="hljs-string">请判断学生的解决方案是否正确，请通过如下步骤解决这个问题：</span><br><span class="hljs-string"></span><br><span class="hljs-string">步骤：</span><br><span class="hljs-string"></span><br><span class="hljs-string">    首先，自己解决问题。</span><br><span class="hljs-string">    然后将您的解决方案与学生的解决方案进行比较，对比计算得到的总费用与学生计算的总费用是否一致，并评估学生的解决方案是否正确。</span><br><span class="hljs-string">    在自己完成问题之前，请勿决定学生的解决方案是否正确。</span><br><span class="hljs-string"></span><br><span class="hljs-string">使用以下格式：</span><br><span class="hljs-string"></span><br><span class="hljs-string">    问题：问题文本</span><br><span class="hljs-string">    学生的解决方案：学生的解决方案文本</span><br><span class="hljs-string">    实际解决方案和步骤：实际解决方案和步骤文本</span><br><span class="hljs-string">    学生计算的总费用：学生计算得到的总费用</span><br><span class="hljs-string">    实际计算的总费用：实际计算出的总费用</span><br><span class="hljs-string">    学生计算的费用和实际计算的费用是否相同：是或否</span><br><span class="hljs-string">    学生的解决方案和实际解决方案是否相同：是或否</span><br><span class="hljs-string">    学生的成绩：正确或不正确</span><br><span class="hljs-string"></span><br><span class="hljs-string">问题：</span><br><span class="hljs-string"></span><br><span class="hljs-string">    我正在建造一个太阳能发电站，需要帮助计算财务。 </span><br><span class="hljs-string">    - 土地费用为每平方英尺100美元</span><br><span class="hljs-string">    - 我可以以每平方英尺250美元的价格购买太阳能电池板</span><br><span class="hljs-string">    - 我已经谈判好了维护合同，每年需要支付固定的10万美元，并额外支付每平方英尺10美元;</span><br><span class="hljs-string"></span><br><span class="hljs-string">    作为平方英尺数的函数，首年运营的总费用是多少。</span><br><span class="hljs-string"></span><br><span class="hljs-string">学生的解决方案：</span><br><span class="hljs-string"></span><br><span class="hljs-string">    设x为发电站的大小，单位为平方英尺。</span><br><span class="hljs-string">    费用：</span><br><span class="hljs-string">    1. 土地费用：100x美元</span><br><span class="hljs-string">    2. 太阳能电池板费用：250x美元</span><br><span class="hljs-string">    3. 维护费用：100,000+100x=10万美元+10x美元</span><br><span class="hljs-string">    总费用：100x美元+250x美元+10万美元+100x美元=450x+10万美元</span><br><span class="hljs-string"></span><br><span class="hljs-string">实际解决方案和步骤：</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>response = get_completion(prompt)<br><span class="hljs-built_in">print</span>(response)<br></code></pre></td></tr></table></figure><h2 id="迭代优化"><a href="#迭代优化" class="headerlink" title="迭代优化"></a>迭代优化</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 示例：产品说明书</span><br>fact_sheet_chair = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">概述</span><br><span class="hljs-string"></span><br><span class="hljs-string">    美丽的中世纪风格办公家具系列的一部分，包括文件柜、办公桌、书柜、会议桌等。</span><br><span class="hljs-string">    多种外壳颜色和底座涂层可选。</span><br><span class="hljs-string">    可选塑料前后靠背装饰（SWC-100）或10种面料和6种皮革的全面装饰（SWC-110）。</span><br><span class="hljs-string">    底座涂层选项为：不锈钢、哑光黑色、光泽白色或铬。</span><br><span class="hljs-string">    椅子可带或不带扶手。</span><br><span class="hljs-string">    适用于家庭或商业场所。</span><br><span class="hljs-string">    符合合同使用资格。</span><br><span class="hljs-string"></span><br><span class="hljs-string">结构</span><br><span class="hljs-string"></span><br><span class="hljs-string">    五个轮子的塑料涂层铝底座。</span><br><span class="hljs-string">    气动椅子调节，方便升降。</span><br><span class="hljs-string"></span><br><span class="hljs-string">尺寸</span><br><span class="hljs-string"></span><br><span class="hljs-string">    宽度53厘米|20.87英寸</span><br><span class="hljs-string">    深度51厘米|20.08英寸</span><br><span class="hljs-string">    高度80厘米|31.50英寸</span><br><span class="hljs-string">    座椅高度44厘米|17.32英寸</span><br><span class="hljs-string">    座椅深度41厘米|16.14英寸</span><br><span class="hljs-string"></span><br><span class="hljs-string">选项</span><br><span class="hljs-string"></span><br><span class="hljs-string">    软地板或硬地板滚轮选项。</span><br><span class="hljs-string">    两种座椅泡沫密度可选：中等（1.8磅/立方英尺）或高（2.8磅/立方英尺）。</span><br><span class="hljs-string">    无扶手或8个位置PU扶手。</span><br><span class="hljs-string"></span><br><span class="hljs-string">材料</span><br><span class="hljs-string">外壳底座滑动件</span><br><span class="hljs-string"></span><br><span class="hljs-string">    改性尼龙PA6/PA66涂层的铸铝。</span><br><span class="hljs-string">    外壳厚度：10毫米。</span><br><span class="hljs-string">    座椅</span><br><span class="hljs-string">    HD36泡沫</span><br><span class="hljs-string"></span><br><span class="hljs-string">原产国</span><br><span class="hljs-string"></span><br><span class="hljs-string">    意大利</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">from</span> tool <span class="hljs-keyword">import</span> get_completion<br><br><span class="hljs-comment"># Prompt ：基于说明书创建营销描述</span><br>prompt = <span class="hljs-string">f&quot;&quot;&quot;</span><br><span class="hljs-string">您的任务是帮助营销团队基于技术说明书创建一个产品的营销描述。</span><br><span class="hljs-string"></span><br><span class="hljs-string">根据```标记的技术说明书中提供的信息，编写一个产品描述。</span><br><span class="hljs-string">可选!: 最多使用50个词</span><br><span class="hljs-string">可选: 处理抓错文本细节:根据不同目标受众关注不同的方面，输出风格和内容上都适合的文本。</span><br><span class="hljs-string"></span><br><span class="hljs-string"></span><br><span class="hljs-string">技术说明: ```<span class="hljs-subst">&#123;fact_sheet_chair&#125;</span>```</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>response = get_completion(prompt)<br><span class="hljs-built_in">print</span>(response)<br><br></code></pre></td></tr></table></figure><h4 id="文本摘取-extract"><a href="#文本摘取-extract" class="headerlink" title="文本摘取 extract"></a>文本摘取 extract</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(review))<br></code></pre></td></tr></table></figure><h3 id="inferring"><a href="#inferring" class="headerlink" title="inferring"></a>inferring</h3><h4 id="情感倾向"><a href="#情感倾向" class="headerlink" title="情感倾向:"></a>情感倾向:</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> tool <span class="hljs-keyword">import</span> get_completion<br>prompt = <span class="hljs-string">f&quot;&quot;&quot;</span><br><span class="hljs-string">三个反引号分割的产品评论的情感是什么</span><br><span class="hljs-string">‘’‘<span class="hljs-subst">&#123;lamp_review&#125;</span></span><br><span class="hljs-string">&#x27;&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="信息提取"><a href="#信息提取" class="headerlink" title="信息提取"></a>信息提取</h4><p>从文本中抽取特定的、我们关心的信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">prompt = <span class="hljs-string">f&quot;&quot;&quot;</span><br><span class="hljs-string"></span><br><span class="hljs-string">从评论文本中识别以下项目：</span><br><span class="hljs-string">- 评论者购买的物品</span><br><span class="hljs-string">- 制造该物品的公司</span><br><span class="hljs-string">- </span><br><span class="hljs-string">评论文本用三个反引号分隔。将你的响应格式化为以 “物品” 和 “品牌” 为键的 JSON 对象。</span><br><span class="hljs-string">如果信息不存在，请使用 “未知” 作为值。</span><br><span class="hljs-string">让你的回应尽可能简短。</span><br><span class="hljs-string">“”“</span><br></code></pre></td></tr></table></figure><h4 id="引入温度系数"><a href="#引入温度系数" class="headerlink" title="引入温度系数"></a>引入温度系数</h4><p>温度控制生成文本的随机性以及多样性,随机程度高,多样性越高,总体来说，temperature 越高，语言模型的文本生成就越具有随机性。可以想象，高温度下，语言模型就像心绪更加活跃，但也可能更有创造力。</p><h2 id="语言模型，提问范式与-Token"><a href="#语言模型，提问范式与-Token" class="headerlink" title="语言模型，提问范式与 Token"></a>语言模型，提问范式与 Token</h2><h3 id="Helper-function-辅助函数-提问范式"><a href="#Helper-function-辅助函数-提问范式" class="headerlink" title="Helper function 辅助函数 (提问范式)"></a>Helper function 辅助函数 (提问范式)</h3><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">delimiter = <span class="hljs-string">&quot;####&quot;</span><br>messages =  [  <br>&#123;<span class="hljs-string">&#x27;role&#x27;</span>:<span class="hljs-string">&#x27;system&#x27;</span>, <br> <span class="hljs-string">&#x27;content&#x27;</span>: system_message&#125;,    <br>&#123;<span class="hljs-string">&#x27;role&#x27;</span>:<span class="hljs-string">&#x27;user&#x27;</span>, <br> <span class="hljs-string">&#x27;content&#x27;</span>: <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;delimiter&#125;</span><span class="hljs-subst">&#123;user_message&#125;</span><span class="hljs-subst">&#123;delimiter&#125;</span>&quot;</span>&#125;,  <br>]<br>messages = []<br></code></pre></td></tr></table></figure><p>在这个例子中，我们使用系统消息（system_message）作为整个系统的全局指导，并选择使用 “#” 作为分隔符。分隔符是用来区分指令或输出中不同部分的工具，它可以帮助模型更好地识别各个部分，从而提高系统在执行特定任务时的准确性和效率。 “#” 也是一个理想的分隔符，因为它可以被视为一个单独的 token 。</p><h4 id="内心独白"><a href="#内心独白" class="headerlink" title="内心独白"></a>内心独白</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    <span class="hljs-keyword">if</span> delimiter <span class="hljs-keyword">in</span> response:<br>        final_response = response.split(delimiter)[-<span class="hljs-number">1</span>].strip()<br>    <span class="hljs-keyword">else</span>:<br>        final_response = response.split(<span class="hljs-string">&quot;:&quot;</span>)[-<span class="hljs-number">1</span>].strip()<br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    final_response = <span class="hljs-string">&quot;对不起，我现在有点问题，请尝试问另外一个问题&quot;</span><br>    <br><span class="hljs-built_in">print</span>(final_response)<br></code></pre></td></tr></table></figure><h3 id="langchain"><a href="#langchain" class="headerlink" title="langchain"></a>langchain</h3><pre><code class="python">from langchain.prompts import ChatPromptTemplatetemplate_string = &quot;&quot;&quot;&quot;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>LLM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>computer_network</title>
    <link href="/2023/09/19/computer-network-1/"/>
    <url>/2023/09/19/computer-network-1/</url>
    
    <content type="html"><![CDATA[<h2 id="Chapter-2"><a href="#Chapter-2" class="headerlink" title="Chapter 2"></a>Chapter 2</h2><h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><p>套接字:</p><ol><li>套接字是同一台主机内应用层与运输层之间的接口。</li><li>因此套接字也称为应用程序和网络之间的应用程序编程接口（Application ProgrammingInterface</li></ol><h4 id="进程寻址"><a href="#进程寻址" class="headerlink" title="进程寻址"></a>进程寻址</h4><p>地址信息:</p><ol><li>主机地址:IP地址是一个32比特的量且它能够唯一地标识该主机就<br>够了</li><li>进程标识:目的地端口号(port number)用于这个目的</li></ol><h4 id="可供应用程序使用的运输服务"><a href="#可供应用程序使用的运输服务" class="headerlink" title="可供应用程序使用的运输服务"></a>可供应用程序使用的运输服务</h4><p>可靠数据传输、 吞吐量、 定时和安全性</p><ol><li><p>可靠数据传输<br> 一些工作以确保由应用程序的一端发送的数据正确、 完全地交付给该应用程序的另一端。如果一个协议提供了这样的确保数据交付服务，就认为提供了可靠数据传输</p></li><li><p>吞吐量<br> 可用吞吐量就是发送进程能够向接收进程交付比特的速率<br> 运输层协议能够以某种特定的速率提供确保的可用吞吐量<br> 而弹性应用（elastic application）能够根据<br> 当时可用的带宽或多或少地利用可供使用的吞吐量</p></li></ol><h5 id="TCP服务"><a href="#TCP服务" class="headerlink" title="TCP服务"></a>TCP服务</h5>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>data-clean</title>
    <link href="/2023/09/16/data-clean/"/>
    <url>/2023/09/16/data-clean/</url>
    
    <content type="html"><![CDATA[<h2 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h2><h3 id="pandas"><a href="#pandas" class="headerlink" title="pandas"></a>pandas</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs python">df.loc[df.AAA &gt;= <span class="hljs-number">5</span>, <span class="hljs-string">&quot;BBB&quot;</span>] = -<span class="hljs-number">1</span><span class="hljs-comment">#数据替换</span><br>df.loc[(df[<span class="hljs-string">&quot;BBB&quot;</span>] &lt; <span class="hljs-number">25</span>) &amp; (df[<span class="hljs-string">&quot;CCC&quot;</span>] &gt;= -<span class="hljs-number">40</span>), <span class="hljs-string">&quot;AAA&quot;</span>]<span class="hljs-comment">#这个操作是直接展现数据</span><br>df.loc[df.AAA &gt;= <span class="hljs-number">5</span>, [<span class="hljs-string">&quot;BBB&quot;</span>, <span class="hljs-string">&quot;CCC&quot;</span>]] = <span class="hljs-number">555</span><span class="hljs-comment">#多数据替换</span><br>df.where(df_mask, -<span class="hljs-number">1000</span>)<span class="hljs-comment">#mask 用false替换掉</span><br>df[<span class="hljs-string">&quot;logic&quot;</span>] = np.where(df[<span class="hljs-string">&quot;AAA&quot;</span>] &gt; <span class="hljs-number">5</span>, <span class="hljs-string">&quot;high&quot;</span>, <span class="hljs-string">&quot;low&quot;</span>)<br><br><br><br><span class="hljs-comment">#数据裁剪 可以直接在变量的列表框中直接进行创建</span><br>df[(df.AAA &lt;= <span class="hljs-number">6</span>) &amp; (df.index.isin([<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>]))]<span class="hljs-comment">#.index表示行的处理方式.可以指定对应的标签</span><br>df2.iloc[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>]  <span class="hljs-comment"># Position-oriented</span><br>df2.loc[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>]  <span class="hljs-comment"># Label-oriented</span><br><br><span class="hljs-comment"># 用映射处理新的列 Efficiently and dynamically creating new columns using DataFrame.map (previously named applymap)</span><br>source_cols = df.columns  <span class="hljs-comment"># 创建出第一列的列名,同时这里是一个列表</span><br>new_cols = [<span class="hljs-built_in">str</span>(x) + <span class="hljs-string">&quot;_cat&quot;</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> source_cols]<span class="hljs-comment">#按照str列名创建</span><br>categories = &#123;<span class="hljs-number">1</span>: <span class="hljs-string">&quot;Alpha&quot;</span>, <span class="hljs-number">2</span>: <span class="hljs-string">&quot;Beta&quot;</span>, <span class="hljs-number">3</span>: <span class="hljs-string">&quot;Charlie&quot;</span>&#125;<span class="hljs-comment">#字典</span><br>df[new_cols] = df[source_cols].<span class="hljs-built_in">map</span>(categories.get)<span class="hljs-comment">#映射的方式</span><br><br><span class="hljs-comment">#有一个重要的函数apply可以把所有的函数运用在特定的位置上</span><br><br><span class="hljs-comment">#merge </span><br>pd.merge(left,right,how=<span class="hljs-string">&quot;left&quot;</span>,on=[])<span class="hljs-comment">#向左边的键位进行连接,同时on表示通过什么键来连接</span><br><br><span class="hljs-comment"># Arithmetic .. Performing arithmetic with a MultiIndex that needs broadcasting</span><br>cols = pd.MultiIndex.from_tuples(<br>    [(x, y) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> [<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>] <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> [<span class="hljs-string">&quot;O&quot;</span>, <span class="hljs-string">&quot;I&quot;</span>]]<br>)<br><span class="hljs-comment">#也就是以上可以创建一个两元的组,同时两者可以同时处理</span><br><br><span class="hljs-comment"># group </span><br><span class="hljs-comment">### 这里可以按照某一个特定的id做一次聚类,再对里面的数据完成操作</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">GrowUp</span>(<span class="hljs-params">x</span>):<br>    avg_weight = <span class="hljs-built_in">sum</span>(x[x[<span class="hljs-string">&quot;size&quot;</span>] == <span class="hljs-string">&quot;S&quot;</span>].weight * <span class="hljs-number">1.5</span>)<br>    avg_weight += <span class="hljs-built_in">sum</span>(x[x[<span class="hljs-string">&quot;size&quot;</span>] == <span class="hljs-string">&quot;M&quot;</span>].weight * <span class="hljs-number">1.25</span>)<br>    avg_weight += <span class="hljs-built_in">sum</span>(x[x[<span class="hljs-string">&quot;size&quot;</span>] == <span class="hljs-string">&quot;L&quot;</span>].weight)<br>    avg_weight /= <span class="hljs-built_in">len</span>(x)<br>    <span class="hljs-keyword">return</span> pd.Series([<span class="hljs-string">&quot;L&quot;</span>, avg_weight, <span class="hljs-literal">True</span>], index=[<span class="hljs-string">&quot;size&quot;</span>, <span class="hljs-string">&quot;weight&quot;</span>, <span class="hljs-string">&quot;adult&quot;</span>])<br><span class="hljs-comment">#weight 权重可以限制其为几倍的操作</span><br><br>pd.Series([i / <span class="hljs-number">100.0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">11</span>)])<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">cum_ret</span>(<span class="hljs-params">x, y</span>):<br>    <span class="hljs-keyword">return</span> x * (<span class="hljs-number">1</span> + y)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">red</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> functools.reduce(cum_ret, x, <span class="hljs-number">1.0</span>)<br><span class="hljs-comment"># 累积运用多次以上的操作</span><br><br><span class="hljs-comment">#注意transform参数的是用一个列作为参数 sort_values 函数通过参量里面的哪一个值来进行计算</span><br>df[<span class="hljs-string">&quot;Counts&quot;</span>] = df.groupby([<span class="hljs-string">&quot;Color&quot;</span>]).transform(<span class="hljs-built_in">len</span>)<span class="hljs-comment">#这里的groupby含有两个元素,但是len会通过广播机制反映到所有的color列中</span><br><br>df[<span class="hljs-string">&quot;beyer_shifted&quot;</span>] = df.groupby(level=<span class="hljs-number">0</span>)[<span class="hljs-string">&quot;beyer&quot;</span>].shift(<span class="hljs-number">1</span>)<span class="hljs-comment">#shift是作为向下移动的过程</span><br>df.groupby(level=<span class="hljs-number">0</span>)<span class="hljs-comment">#对于第一个列进行索引</span><br><br><br><br><br></code></pre></td></tr></table></figure><h2 id="数据清洗"><a href="#数据清洗" class="headerlink" title="数据清洗"></a>数据清洗</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;\n&quot;</span>.join(<span class="hljs-built_in">list</span>) <span class="hljs-comment">#表示用list字符重新生成字符串,同时里面内容用\n切割</span><br>[::-<span class="hljs-number">1</span>]<span class="hljs-comment">#从后向前遍历</span><br>[<span class="hljs-number">5</span>::<span class="hljs-number">6</span>]<span class="hljs-comment">#表示从5起,步长为6开始遍历</span><br><br></code></pre></td></tr></table></figure><h2 id="simpy"><a href="#simpy" class="headerlink" title="simpy"></a>simpy</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> simpy<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    env = simpy.Environment()<br>    env.process(traffic_light(env))<br>    env.run(until=<span class="hljs-number">120</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;simulation done&#x27;</span>)<br>    <br><span class="hljs-comment"># traffic_light是一个process，传入env是告诉traffic_light它是在env里执行的，而不是其它环境</span><br><span class="hljs-comment">#yield 可以随时的从当前的时间段停下来,然后下一次读取的时候在重复</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">traffic_light</span>(<span class="hljs-params">env</span>):<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;light green at :<span class="hljs-subst">&#123;env.now&#125;</span>&#x27;</span>)<br>        <span class="hljs-keyword">yield</span> env.timeout(<span class="hljs-number">30</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;light yellow at :<span class="hljs-subst">&#123;env.now&#125;</span>&#x27;</span>)<br>        <span class="hljs-keyword">yield</span> env.timeout(<span class="hljs-number">5</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;light red at :<span class="hljs-subst">&#123;env.now&#125;</span>&#x27;</span>)<br>        <span class="hljs-keyword">yield</span> env.timeout(<span class="hljs-number">20</span>)<br>        <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">example</span>(<span class="hljs-params">env</span>):<br>        value = <span class="hljs-keyword">yield</span> env.timeout(env,delay=<span class="hljs-number">1</span>,value=<span class="hljs-number">42</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;now=%d,value=%d&#x27;</span>%(env.now,value))<br>env = simpy.Environment()<br>p = env.process(example(env))<br></code></pre></td></tr></table></figure><p>generate是一种迭代器,一次只能使用一个值,同时这个只能使用一次,之后相当于会忘记这里的值,也就是无法使用这个行为<br>yield 是一个用法与return类似的关键词，只是这个函数返回一个生成器<br>调用包含yield的函数会返回一个生成器，函数中的代码并没有运行，调用生成器后，每次遇到 yield 时函数会暂停并保存当前所有的运行信息（保留局部变量），返回 yield 的值, 并在下一次迭代时从当前位置继续运行，直到生成器被全部遍历完。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_generator</span>():<br>    mylist = <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> mylist:<br>    <span class="hljs-keyword">yield</span> i*i<br>mygenerator = create_generator()<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> mygenerator:<br>    <span class="hljs-built_in">print</span>(i)<br>env.run(until=<span class="hljs-number">10</span>)<span class="hljs-comment">#会一直运行10s</span><br></code></pre></td></tr></table></figure><p>Environment.active_process：获取当前执行的进程，只有在进程函数里能获取到该信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> simpy<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">subfunc</span>(<span class="hljs-params">env</span>):<br>    <span class="hljs-built_in">print</span>(env.active_process)<span class="hljs-comment">#process创建进程,run执行</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">proc</span>(<span class="hljs-params">env</span>):<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-built_in">print</span>(env.active_process)<br>        subfunc(env)<br>        <span class="hljs-keyword">yield</span> env.timeout(<span class="hljs-number">1</span>)<span class="hljs-comment">#进程应该采用的阻塞器的方式做出生成器的方式</span><br>env = simpy.Environment()<br>p1 = env.process(proc(env))  <br></code></pre></td></tr></table></figure><h4 id="event-basic"><a href="#event-basic" class="headerlink" title="event basic"></a>event basic</h4><p>3种状态:<br>    1. 将要发生triggered &#x3D; True 放入事件队列中<br>    2. 可能发生triggered &#x3D; False<br>    3. 已经发生processed &#x3D; True 处理,就会弹出<br>Event.callbacks：回调列表，只要event没有被处理，就可以添加回调。回调就是event以参数的形式存储在Event.callbacks列表中<br>触发后,可能成功也可能失败<br>Event.succeed(value&#x3D;None)：触发一件event并将其标记为成功<br>Event.fail(exception)：触发event失败，并闯入原因<br>Event.trigger(event)：触发event通用方法，返回成功或者失败的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> simpy<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">school</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, env</span>):<br>        self.env = env<br>        self.class_end = env.event()<br>        <span class="hljs-comment"># 创建三个pupil进程和一个bell进程</span><br>        self.pupil_procs = [env.process(self.pupil()) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>)]<br>        self.bell_procs = env.process(self.bell())<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">bell</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>): <span class="hljs-comment"># （1）bell循环</span><br>            <span class="hljs-keyword">yield</span> self.env.timeout(<span class="hljs-number">45</span>)  <span class="hljs-comment"># （2）等待45</span><br>            self.class_end.succeed()  <span class="hljs-comment"># （3）触发class_end标记成功</span><br>            self.class_end = self.env.event()  <span class="hljs-comment"># （4）生成新的class_end事件</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pupil</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>):  <span class="hljs-comment"># （5）pupil循环</span><br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">r&#x27;\0/&#x27;</span>,end=<span class="hljs-string">&#x27; &#x27;</span>)  <span class="hljs-comment"># （6）输出\0/</span><br>            <span class="hljs-keyword">yield</span> self.class_end  <span class="hljs-comment">#（7）中断处理class_end事件</span><br>school = School(env)<br>env = simpy.Environment()<br>env.run()        <br><br><span class="hljs-comment"># charge &amp; run</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, env</span>):<br>        self.env = env<br>        <span class="hljs-comment"># Start the run process everytime an instance is created.</span><br>        self.action = env.process(self.run())<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Start parking and charging at %d&#x27;</span> % self.env.now)<br>            charge_duration = <span class="hljs-number">5</span><br>            <span class="hljs-comment"># We yield the process that process() returns</span><br>            <span class="hljs-comment"># to wait for it to finish</span><br>            <span class="hljs-keyword">yield</span> self.env.process(self.charge(charge_duration))<br><br>            <span class="hljs-comment"># The charge process has finished and</span><br>            <span class="hljs-comment"># we can start driving again.</span><br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Start driving at %d&#x27;</span> % self.env.now)<br>            trip_duration = <span class="hljs-number">2</span><br>            <span class="hljs-keyword">yield</span> self.env.timeout(trip_duration)<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">driver</span>(<span class="hljs-params">env, car</span>):<br>        <span class="hljs-keyword">yield</span> env.timeout(<span class="hljs-number">3</span>)<br>        car.action.interrupt()<span class="hljs-comment">#进程的中断</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">charge</span>(<span class="hljs-params">self, duration</span>):<br>        <span class="hljs-keyword">yield</span> self.env.timeout(duration) <span class="hljs-comment">#yield 本身也是作为返回一种迭代器的方式返回</span><br>        <span class="hljs-comment">#需要n </span><br>    <span class="hljs-keyword">import</span> simpy<br>    env = simpy.Environment()<br>    car = Car(env)<br>    env.run(until=<span class="hljs-number">15</span>)<br><br><span class="hljs-comment">### !!!! 注意进程的创建本身也是在加入一个函数里面含有yield函数即可 </span><br><span class="hljs-comment">#### 采用interupt函数中断</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, env</span>):<br>        self.env = env<br>        self.action = env.process(self.run())<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Start parking and charging at %d&#x27;</span> % self.env.now)<br>            charge_duration = <span class="hljs-number">5</span><br>            <span class="hljs-comment"># We may get interrupted while charging the battery</span><br>            <span class="hljs-keyword">try</span>:<br>                <span class="hljs-keyword">yield</span> self.env.process(self.charge(charge_duration))<br>            <span class="hljs-keyword">except</span> simpy.Interrupt:<br>                <span class="hljs-comment"># When we received an interrupt, we stop charging and</span><br>                <span class="hljs-comment"># switch to the &quot;driving&quot; state</span><br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Was interrupted. Hope, the battery is full enough ...&#x27;</span>)<br><br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Start driving at %d&#x27;</span> % self.env.now)<br>            trip_duration = <span class="hljs-number">2</span><br>            <span class="hljs-keyword">yield</span> self.env.timeout(trip_duration)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">charge</span>(<span class="hljs-params">self, duration</span>):<br>        <span class="hljs-keyword">yield</span> self.env.timeout(duration)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">example</span>(<span class="hljs-params">env</span>):<br>    event = simpy.events.Timeout(env, delay=<span class="hljs-number">1</span>, value=<span class="hljs-number">42</span>)<br>    value = <span class="hljs-keyword">yield</span> event<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;now=%d, value=%d&#x27;</span> % (env.now, value))<br>env = simpy.Environment()<br>example_gen = example(env)<br>p = simpy.events.Process(env, example_gen)<br>env.run()<span class="hljs-comment"># 可以通过value函数,在yield 后返回一个对应的value的值</span><br><br><span class="hljs-comment"># run同时可以传递一个process进去此时run会返回相关的函数的return值</span><br><br></code></pre></td></tr></table></figure><p>peek() returns the time of the next scheduled event or infinity (float(‘inf’)) if no future events are scheduled.</p><p>step() processes the next scheduled event. It raises an EmptySchedule exception if no event is available.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs python">until = <span class="hljs-number">10</span><br><span class="hljs-keyword">while</span> env.peek() &lt; until:<br>   env.step()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">subfunc</span>(<span class="hljs-params">env</span>):<br>    <span class="hljs-built_in">print</span>(env.active_process)  <span class="hljs-comment"># will print &quot;p1&quot; 指向当前执行进程的pid</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_proc</span>(<span class="hljs-params">env</span>):<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-built_in">print</span>(env.active_process)  <span class="hljs-comment"># will print &quot;p1&quot;</span><br>        subfunc(env)<br>        <span class="hljs-keyword">yield</span> env.timeout(<span class="hljs-number">1</span>)<br><br>env = simpy.Environment()<br>p1 = env.process(my_proc(env))<br>env.active_process  <span class="hljs-comment"># None</span><br>env.step()<br><br><span class="hljs-comment"># callback list</span><br><span class="hljs-keyword">import</span> simpy<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_callback</span>(<span class="hljs-params">event</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Called back from&#x27;</span>, event)<br><br>env = simpy.Environment()<br>event = env.event()<span class="hljs-comment">#相当于创建一个时间对象,之后开始修改并运用</span><br>event.callbacks.append(my_callback)<br>event.callbacks<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">School</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, env</span>):<br>        self.env = env<br>        self.class_ends = env.event()<span class="hljs-comment">#这里初始化了一个对象,重复调用只能去调用这个对象中已经使用的部分,而不能重复调用这个创建函数</span><br>        <span class="hljs-comment"># init函数</span><br>        self.pupil_procs = [env.process(self.pupil()) <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>)]<br>        self.bell_proc = env.process(self.bell())<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">bell</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>):<br>            <span class="hljs-keyword">yield</span> self.env.timeout(<span class="hljs-number">45</span>)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;hi&quot;</span>)<br>            self.class_ends.succeed()<br>            self.class_ends = self.env.event()<br>            <span class="hljs-built_in">print</span>(env.now)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pupil</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">r&#x27; \o/ &#x27;</span>, end=<span class="hljs-string">&#x27;&#x27;</span> )<br>            <span class="hljs-keyword">yield</span> self.class_ends <span class="hljs-comment">#yield 创建了,然后直接切断,进行下一个时间,</span><br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;hello&quot;</span>)<br>env = simpy.Environment()<br>school = School(env)<br>env.run()<br><br><span class="hljs-comment">#process as event</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sub</span>(<span class="hljs-params">env</span>):<br>    <span class="hljs-keyword">yield</span> env.timeout(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">23</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">parent</span>(<span class="hljs-params">env</span>):<br>    ret = <span class="hljs-keyword">yield</span> env.process(sub(env))<span class="hljs-comment">#相当于等待子进程完成之后在</span><br>    <span class="hljs-keyword">return</span> ret<br><br><br><span class="hljs-comment"># Waiting for multiple events at once</span><br><span class="hljs-keyword">from</span> simpy.events <span class="hljs-keyword">import</span> AnyOf, AllOf, Event<br>events = [Event(env) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>)]<br>a = AnyOf(env, events)  <span class="hljs-comment"># Triggers if at least one of &quot;events&quot; is triggered.</span><br>b = AllOf(env, events)  <span class="hljs-comment"># Triggers if all each of &quot;events&quot; is triggered.</span><br><br><span class="hljs-comment">#  创建以上的方式 ,events作为对象列来等待操作</span><br></code></pre></td></tr></table></figure><p>限制了函数的执行</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>编译原理</title>
    <link href="/2023/09/10/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    <url>/2023/09/10/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h1><h2 id="复杂指针的说明"><a href="#复杂指针的说明" class="headerlink" title="复杂指针的说明"></a>复杂指针的说明</h2><h3 id="base"><a href="#base" class="headerlink" title="base"></a>base</h3><ol><li>[]的解析方式 a[4] &#x3D; *(a+4)</li><li>[]的优先级高于 * 也就是一般来说先从向右看,再向左看.同时翻译的顺序是从内向外进行</li><li>(*p)[N] p作为指针,元素类型是数组 翻译为 *((*p)+n)</li><li>*(*p)[N] 含义是p是一个指针指向n个元素,里面都是指针的数组</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>computer_network</title>
    <link href="/2023/09/10/computer-network/"/>
    <url>/2023/09/10/computer-network/</url>
    
    <content type="html"><![CDATA[<h2 id="chapter-1"><a href="#chapter-1" class="headerlink" title="chapter 1"></a>chapter 1</h2><h3 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h3><p><strong>网络核心</strong>:由路由器和链路形成的网状网络<br>任务: 将数据包从发送侧的边缘路由器，传送到接收侧的边缘路由器,将全球的ISP连接到一起<br>移动数据的两种基本方法：</p><ol><li>电路交换</li><li>分组交换</li></ol><h4 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h4><ol><li>主机将要传输的数据分段，并组装成一系列分组</li><li>交换:在传输路径上，交换设备从一条链路上接收分组，将其发送到另一条链路上</li><li>存储转发:交换设备在接收到完整的分组后，才可以开始转发</li></ol><p>序列化延迟:P 个分组经过 N 条链路的总耗时是多少？<br>(P+N-1)L&#x2F;R</p><p>排队延迟与丢包:<br>排队延迟: 分组在输出链路的缓存中排队，引入延迟<br>丢包:若输出链路的缓存满，溢出的分组被丢弃<br>大量的分组集中到达时:</p><h4 id="重要功能"><a href="#重要功能" class="headerlink" title="重要功能"></a>重要功能</h4><p>routing(选路):交换设备确定不同的目的转发端口,生成转发表<br>forwarding(转发):交换设备按照转发表,将分组移动到相应的输出联路</p><h4 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h4><p>通话前完成两部电话机之间的电路接续，通话结束后释放整条电路<br>本质是:<strong>预留资源和独占资源</strong></p><p>链路(link):物理媒介 信道<br>电路:无力媒体中的一条子信道</p><p>分组交换的好处:同样的链路连接,分组交换支持更多的用户<br>统计复用（分组交换）：信道使用模式不固定<br>同步时分复用（电路交换）：信道使用模式固定</p><h4 id="网络的网络"><a href="#网络的网络" class="headerlink" title="网络的网络"></a>网络的网络</h4><p>英特网是一群ISP组成的网络的网络</p><p>生态系统:</p><ol><li>接入ISP</li><li>地区ISP</li><li>第一层ISP</li><li>对等链路</li><li>因特网交换点IXP：多个ISP共同对等的地方</li><li>存在点PoP（Point of Presence）：低层ISP接入高层ISP的地方</li><li>多宿（multi-home）：一个低层ISP可以接入多个高层ISP</li></ol><h3 id="衡量网络性能的主要指标"><a href="#衡量网络性能的主要指标" class="headerlink" title="衡量网络性能的主要指标"></a>衡量网络性能的主要指标</h3><p><strong>延迟</strong>:从源终端到目的终端的时间<br><strong>丢包率</strong>:未成功交付到目的终端的分组比例<br><strong>吞吐量</strong>:单位时间内网络的成功交付的数据量</p><p>分组延迟:</p><ol><li>节点处理:检查错误,确定输出联路</li><li>排队:输出缓存等待传输 时间长度取决于链路负载大小</li><li>传输延迟:链路速率</li><li>传播延迟:链路长度</li></ol><h2 id="chapter-3"><a href="#chapter-3" class="headerlink" title="chapter 3"></a>chapter 3</h2><h3 id="rdt-2-1"><a href="#rdt-2-1" class="headerlink" title="rdt 2.1"></a>rdt 2.1</h3><p>为了解决:发送方不理解自己说的话引申出来的问题,也就是发送方无法理解是ACK of NAK, 所以选择直接重传,但是接收方是正常的<br>发送方4个状态:</p><ul><li>添加了检查包是否损坏</li><li>在发送状态(1,3)需要控制发送0,1序列<br>接受方2个状态</li><li>出错发送NAK</li><li>损坏发送NAK</li><li>冗余发送ACK,但是不交付数据</li></ul><p>2.2相当于在用上一个分组来当作后一个分组的值,如果上一个分组,所以ack编码相当于减少了一半,同时需要引入超时重传机制,用一个定时计时器.</p><h3 id="rdt-3-0"><a href="#rdt-3-0" class="headerlink" title="rdt 3.0"></a>rdt 3.0</h3><p>超时直接重放<br>如果超时定时器设置不合理:</p><ol><li>过早超时,ack1 会导致次序混乱.过早超时</li></ol><p>效率比较低,</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>当前时间å+前面的(1-å)的指数规律进行采用.</p><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>滑动窗口保留在最后一位的接收到的字节的下一位上面,同时不会选择回传<br>同时辅助定时器,可以选择隐忍不发,后面到达发送后面ack<br>后先于前,返回前面ack,突然补齐了就给后面的断<br><strong>快速重传</strong>:突然收到多个相同ack直接选择重传</p><h5 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h5>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>recommandation</title>
    <link href="/2023/09/06/recommandation/"/>
    <url>/2023/09/06/recommandation/</url>
    
    <content type="html"><![CDATA[<h1 id="recommendaion-system"><a href="#recommendaion-system" class="headerlink" title="recommendaion system"></a>recommendaion system</h1><h2 id="merics"><a href="#merics" class="headerlink" title="merics"></a>merics</h2><h3 id="ndcg"><a href="#ndcg" class="headerlink" title="ndcg"></a>ndcg</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>np.random.seed(<span class="hljs-number">2021</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Model</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, k</span>):<br>        self.k = k<br>        self.item_size = <span class="hljs-number">50</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self, users</span>):<br>        <span class="hljs-comment"># 模型随机返回 k 个 item,模拟推荐结果</span><br>        res = np.random.randint(<span class="hljs-number">0</span>, self.item_size, users.shape[<span class="hljs-number">0</span>] * self.k)<span class="hljs-comment">#随机生成数组的整数,生成的大小位于前两个参数之间,生成的长度是第三个参数</span><br>        <span class="hljs-keyword">return</span> res.reshape((users.shape[<span class="hljs-number">0</span>], -<span class="hljs-number">1</span>)) <span class="hljs-comment">#reshape是转换为二位数组 行数用前一个参数确定,-1指的是列数自动确定</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_implict_matrix</span>(<span class="hljs-params">rec_items, test_set</span>):<br>    rel_matrix = [[<span class="hljs-number">0</span>] * rec_items.shape[<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(rec_items.shape[<span class="hljs-number">0</span>])]<span class="hljs-comment">#shape[1]定义了列数,同时[0]*把所有的元素赋值为零</span><br>    <span class="hljs-keyword">for</span> user <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(test_set)):<br>        <span class="hljs-keyword">for</span> index, item <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(rec_items[user]):<br>            <span class="hljs-keyword">if</span> item <span class="hljs-keyword">in</span> test_set[user]:<br>                rel_matrix[user][index] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> np.array(rel_matrix)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">DCG</span>(<span class="hljs-params">items</span>):<br>    <span class="hljs-keyword">return</span> np.<span class="hljs-built_in">sum</span>(items / np.log(np.arange(<span class="hljs-number">2</span>, <span class="hljs-built_in">len</span>(items) + <span class="hljs-number">2</span>))) <span class="hljs-comment"># np.sum传入数组可以实现对于数组中两个数以此 同时需要采用的np.array的数据类型</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">nDCG</span>(<span class="hljs-params">rec_items, test_set</span>):<br>    <span class="hljs-keyword">assert</span> rec_items.shape[<span class="hljs-number">0</span>] == <span class="hljs-built_in">len</span>(test_set)<br>    <span class="hljs-comment"># 获得隐式反馈的rel分数矩阵</span><br>    rel_matrix = get_implict_matrix(rec_items, test_set)<br>    ndcgs = []<br>    <span class="hljs-keyword">for</span> user <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(test_set)):<br>        rels = rel_matrix[user]<br>        dcg = DCG(rels)<br>        idcg = DCG(<span class="hljs-built_in">sorted</span>(rels, reverse=<span class="hljs-literal">True</span>))<span class="hljs-comment">#作为最理想的定义方法,以此定义排序方法的好坏</span><br>        ndcg = dcg / idcg <span class="hljs-keyword">if</span> idcg != <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span><br>        ndcgs.append(ndcg)<br>    <span class="hljs-keyword">return</span> ndcgs<br><br><br><span class="hljs-comment"># 假设 top-20 推荐,一共 5 个 user, 50 个 item ,隐式反馈数据集.</span><br>users = np.array([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])<br><span class="hljs-comment"># test_set 表示 5 个用户在测试集中分表交互过那些 item</span><br>test_set = [<br>    [<span class="hljs-number">0</span>, <span class="hljs-number">21</span>, <span class="hljs-number">31</span>, <span class="hljs-number">41</span>, <span class="hljs-number">49</span>],<br>    [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">33</span>],<br>    [<span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">39</span>, <span class="hljs-number">44</span>, <span class="hljs-number">45</span>, <span class="hljs-number">49</span>],<br>    [<span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">13</span>, <span class="hljs-number">15</span>],<br>    [<span class="hljs-number">2</span>]<br>]<br><br>model = Model(<span class="hljs-number">20</span>)<br>rec_items = model(users)<br>ndcgs = nDCG(rec_items, test_set)<br><span class="hljs-built_in">print</span>(ndcgs)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>algorithms</title>
    <link href="/2023/09/05/algorithms/"/>
    <url>/2023/09/05/algorithms/</url>
    
    <content type="html"><![CDATA[<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p>密码:alg23</p><h2 id="算法初步"><a href="#算法初步" class="headerlink" title="算法初步"></a>算法初步</h2><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">insertinSort</span>(A)<br>&#123;<br>    <span class="hljs-comment">//输入数组并完成排序</span><br>    <span class="hljs-keyword">for</span> j=<span class="hljs-number">2</span> to <span class="hljs-built_in">length</span>(A) <span class="hljs-keyword">do</span><br><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>伪代码的写法 - 类c语言</li><li>插入排序是稳定的</li><li>快排序是非稳定的</li><li>如何对待伪代码进行优化</li></ul><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><ul><li><p>预测使用的资源</p><ul><li>计算时间</li><li>存储空间</li><li>通讯带宽</li><li>n个算法,分析时需要考虑计算机体系结构以及计算模型</li><li>控制 数据移动 运算 均假设需要一个标准时间</li><li>数据类型:Integer,floating point</li><li>计算2的k次方视作单位1,内存存取视作单位1时间,同时不分层次且容量无限</li></ul></li><li><p>插入排序的时间分析</p><ol><li>影响时间的因素:输入规模,输入数据分布,计算时间用关于size的函数表示,与算法实现的数据结构相关,</li><li>运行时间 基本操作数,执行步数 :度量的标准<ol><li>最好时间(best case running time):dn是Tsigz的输入规模 $I_n \in D_n$ $P(I)\text{是I出现的概率}$</li><li>tag:<strong>for语句每次执行的次数比循环体内部语句执行次数多一次</strong></li></ol></li></ol></li></ul><h3 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h3><ol><li>divide and conquer &#x2F;&#x2F;</li><li>Greedy strategy</li><li>dynamic pragram</li></ol><h4 id="分治法-divide-and-conquer"><a href="#分治法-divide-and-conquer" class="headerlink" title="分治法(divide and conquer)"></a>分治法(divide and conquer)</h4><h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><h4 id="mid"><a href="#mid" class="headerlink" title="mid"></a>mid</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">Random_select</span>(<span class="hljs-params">A,p,r,i</span>):<br>    <span class="hljs-keyword">if</span> p == r:<br>      <span class="hljs-keyword">return</span> A[p]<br>    q = Random_partition(A,p,r)<br>    k = q-p+<span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> i == k:<br>      <span class="hljs-keyword">return</span> A[q]<br>    <span class="hljs-keyword">elif</span> i&lt;k:<br>      <span class="hljs-keyword">return</span> Random_select(A,p,r,q-<span class="hljs-number">1</span>,i)<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> Random_select(A,q+<span class="hljs-number">1</span>,r,i-k)<br>  <br></code></pre></td></tr></table></figure><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><ol><li>根B</li><li>NIL是B</li><li>node R children是B</li><li>节点到后代叶节点的路径,含有的相同数目B相同</li></ol><p><strong>黑高</strong>:从结点x出发到达任何一个简单路径的黑色节点的个数称为该结点的黑高</p><p><strong>13.1</strong>含有n个内部结点的高度至多为$2\lg (n+1)$<br>  归纳: 子节点的黑高bh(x) or bh(x) -1 ,所以以x为根,含有结点$x^{bh(x)-1} -1$</p><h4 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h4><p>类似于根的左右旋转</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">left_rotate</span>(<span class="hljs-params">T,x</span>):<br>  y = x.right<br>  x.right = y.left<br>  <span class="hljs-keyword">if</span> y.left != T.nil:<br>      y.left.p = x<br>  y.p = x.p<br>  <span class="hljs-keyword">if</span> x.p == T.nil: <span class="hljs-comment"># x是根结点</span><br>    T.root = y<br>  <span class="hljs-keyword">elif</span> x == x.p.left:<br>    x.p.left = y<br>  <span class="hljs-keyword">else</span> x.p.right = y<br>  y.left = x<br>  x.p = y<span class="hljs-comment"># 相当于多了一个父结点需要修正</span><br></code></pre></td></tr></table></figure><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>z插入T,同时z着红色,同时调用新的程序进行修正</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">RB_INSERT</span>(<span class="hljs-params">T,z</span>):<br>  y = T.nil<br>  x = T.root<br>  While x != T.nil<br></code></pre></td></tr></table></figure><p>修正产生的情况(插入红结点不会改变任意位置的黑高,同时自己本身就是最后一个位置)</p><ol><li>父,叔结点都是红的,父叔结点转换为黑,同时上移爷爷(黑)结点转为红,这样会面对父结点是红,但是自己是红,但是叔结点是黑</li><li>在左孩子上面的情况下,可以统一的变换成左边连续两红结点的情况</li></ol><h4 id="删除的方法"><a href="#删除的方法" class="headerlink" title="删除的方法"></a>删除的方法</h4><p>只有在z左右不是双空的情况下需要进行调整,同时采用的删除方式是,找到右子树的最左端结点,删除,同时把他的值填入Z,也就是y的右子树可能需要进行调整,同时x仅仅是一个子树,现在y删除之后,上面没有变动,现在需要依据y</p><ol><li>y是红,没有任何影响</li><li>y是黑,x下面缺了一个黑<ol><li>x是红的,直接涂黑</li><li>x已经是黑的,相当于少了一个黑,我们假定他是双黑<ol><li>把情况变换成右子树是黑的<ol><li>w孩子都是黑的把父结点增黑,兄弟变白,现在矛盾转移到了父结点</li><li>w的右子树是黑,左子树是红</li></ol></li></ol></li></ol></li></ol><h4 id="秩"><a href="#秩" class="headerlink" title="秩"></a>秩</h4><p>秩的确定:</p><ol><li>确定自己在以自己为根r的大小</li><li>直到root之前,如果自己是左孩子,那么自己不需要考虑父结点孩子的影响,如果自己是右孩子,那么自己还要加上父结点以及自己的兄弟的值.同时上移自己考虑父结点相关的影响</li></ol><p><strong>插入结点后的维护</strong>:</p><ol><li>经历后的结点的size需要加1</li><li>修正算法最多增加两个旋转,旋转算法也需要增加相关的size的修正</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>leetcode</title>
    <link href="/2023/08/26/leetcode/"/>
    <url>/2023/08/26/leetcode/</url>
    
    <content type="html"><![CDATA[<h1 id="算法代码阅读"><a href="#算法代码阅读" class="headerlink" title="算法代码阅读"></a>算法代码阅读</h1><h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><h4 id="两数之和-1"><a href="#两数之和-1" class="headerlink" title="两数之和 -1"></a>两数之和 -1</h4><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">twoSum</span>(<span class="hljs-params">self, nums, target</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :type target: int</span><br><span class="hljs-string">        :rtype: List[int]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span> <span class="hljs-comment">#这里应该是判断用的</span><br>        <span class="hljs-comment"># 遍历列表</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-comment"># 计算需要找到的下一个目标数字</span><br>            res = target-nums[i]<br>                <span class="hljs-comment"># i个数字的对应的大小放在 i的空间上</span><br>            <span class="hljs-keyword">if</span> res <span class="hljs-keyword">in</span> nums[i+<span class="hljs-number">1</span>:]:<br><br><br>                <span class="hljs-comment"># 若存在，返回答案。这里由于是两数之和，可采用.index()方法</span><br>                <span class="hljs-comment"># 获得目标元素在nums[i+1:]这个子数组中的索引后，还需加上i+1才是该元素在nums中的索引</span><br>                <span class="hljs-keyword">return</span> [i, nums[i+<span class="hljs-number">1</span>:].index(res)+i+<span class="hljs-number">1</span>] <span class="hljs-comment">#index(值用的是直接索引出标签、)</span><br><br><span class="hljs-comment"># 时间复杂读为 n^2</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">twoSum</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        idx = &#123;&#125;  <span class="hljs-comment"># 创建一个空哈希表（字典）</span><br>        <span class="hljs-keyword">for</span> j, x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):  <span class="hljs-comment"># x=nums[j]</span><br>            <span class="hljs-keyword">if</span> target - x <span class="hljs-keyword">in</span> idx:  <span class="hljs-comment"># 在左边找 nums[i]，满足 nums[i]+x=target</span><br>                <span class="hljs-keyword">return</span> [idx[target - x], j]  <span class="hljs-comment"># 返回两个数的下标</span><br>            idx[x] = j  <span class="hljs-comment"># 保存 nums[j] 和 j</span><br><br><span class="hljs-comment">#hash表的映射关系, a[i] = x 令 b[x] = i 对于target - x 只要检测后表是不是有这个值即可</span><br><br></code></pre></td></tr></table></figure><h3 id="两数相加-2"><a href="#两数相加-2" class="headerlink" title="两数相加 -2"></a>两数相加 -2</h3><p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-comment"># l1 和 l2 为当前遍历的节点，carry 为进位</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">addTwoNumbers</span>(<span class="hljs-params">self, l1: <span class="hljs-type">Optional</span>[ListNode], l2: <span class="hljs-type">Optional</span>[ListNode], carry=<span class="hljs-number">0</span></span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<span class="hljs-comment">#Optional表示可以是ListNode类型也可以是None类型</span><br>        <span class="hljs-comment">#递归的结束标志</span><br>        <span class="hljs-keyword">if</span> l1 <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> l2 <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:  <span class="hljs-comment"># 递归边界：l1 和 l2 都是空节点</span><br>            <span class="hljs-keyword">return</span> ListNode(carry) <span class="hljs-keyword">if</span> carry <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span>  <span class="hljs-comment"># 创建一个节点值为carry的结点</span><br>            <span class="hljs-comment">#进位的标志</span><br>        <span class="hljs-keyword">if</span> l1 <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:  <span class="hljs-comment"># 令l1一直是长的节点</span><br>            l1, l2 = l2, l1  <br><br>        carry += l1.val + (l2.val <span class="hljs-keyword">if</span> l2 <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>)  <span class="hljs-comment"># 这个语句不需要修正是否为零的长度</span><br>        l1.val = carry % <span class="hljs-number">10</span>  <span class="hljs-comment"># 每个节点保存一个数位</span><br>        l1.<span class="hljs-built_in">next</span> = self.addTwoNumbers(l1.<span class="hljs-built_in">next</span>, l2.<span class="hljs-built_in">next</span> <span class="hljs-keyword">if</span> l2 <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span>, carry // <span class="hljs-number">10</span>)  <span class="hljs-comment"># 进位 已经正确的决定l2的长度</span><br>        <span class="hljs-comment">#carry</span><br>        <span class="hljs-keyword">return</span> l1<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">addTwoNumbers</span>(<span class="hljs-params">self, l1: <span class="hljs-type">Optional</span>[ListNode], l2: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>        cur = dummy = ListNode()  <span class="hljs-comment"># 哨兵节点</span><br>        carry = <span class="hljs-number">0</span>  <span class="hljs-comment"># 进位</span><br>        <span class="hljs-keyword">while</span> l1 <span class="hljs-keyword">or</span> l2 <span class="hljs-keyword">or</span> carry:  <span class="hljs-comment"># 有一个不是空节点，或者还有进位，就继续迭代</span><br>            carry += (l1.val <span class="hljs-keyword">if</span> l1 <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>) + (l2.val <span class="hljs-keyword">if</span> l2 <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>)  <span class="hljs-comment"># 节点值和进位加在一起</span><br>            cur.<span class="hljs-built_in">next</span> = ListNode(carry % <span class="hljs-number">10</span>)  <span class="hljs-comment"># 每个节点保存一个数位</span><br>            carry //= <span class="hljs-number">10</span>  <span class="hljs-comment"># 新的进位</span><br>            cur = cur.<span class="hljs-built_in">next</span>  <span class="hljs-comment"># 下一个节点</span><br>            <span class="hljs-keyword">if</span> l1: l1 = l1.<span class="hljs-built_in">next</span>  <span class="hljs-comment"># 下一个节点</span><br>            <span class="hljs-keyword">if</span> l2: l2 = l2.<span class="hljs-built_in">next</span>  <span class="hljs-comment"># 下一个节点</span><br>        <span class="hljs-keyword">return</span> dummy.<span class="hljs-built_in">next</span>  <span class="hljs-comment"># 哨兵节点的下一个节点就是头节点</span><br><br><br></code></pre></td></tr></table></figure><h4 id="无重复字符的最长子串-3"><a href="#无重复字符的最长子串-3" class="headerlink" title="无重复字符的最长子串 -3"></a>无重复字符的最长子串 -3</h4><p>给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-comment">#滑动窗口以及 哈希表</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">lengthOfLongestSubstring</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>: <span class="hljs-comment">#这个应该是定义了内部变量的以及函数的返回类型</span><br>        dic, res, i = &#123;&#125;, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):<br>            <span class="hljs-keyword">if</span> s[j] <span class="hljs-keyword">in</span> dic: <span class="hljs-comment">#如果在表的位置上查到了这个的值也就是重复了</span><br>            <span class="hljs-comment"># 识别出每一个重复的左指标,以及这个采取缩减的方式,完成了一起更新,还有比较的模式</span><br>                i = <span class="hljs-built_in">max</span>(dic[s[j]], i) <span class="hljs-comment"># 更新左指针 i</span><br>            dic[s[j]] = j <span class="hljs-comment"># 在表的s[j]放入 在字符串s中的位置 也就是可以一一映射的</span><br>            res = <span class="hljs-built_in">max</span>(res, j - i) <span class="hljs-comment"># 更新结果</span><br>        <span class="hljs-keyword">return</span> res<br><br><span class="hljs-comment">#动态规划加hash 鉴定为脑瘫东西</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">lengthOfLongestSubstring</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        dic = &#123;&#125;<br>        res = tmp = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):<br>            i = dic.get(s[j], -<span class="hljs-number">1</span>) <span class="hljs-comment"># 获取索引 i</span><br>            dic[s[j]] = j <span class="hljs-comment"># 更新哈希表</span><br>            <br>            tmp = tmp + <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> tmp &lt; j - i <span class="hljs-keyword">else</span> j - i <span class="hljs-comment"># dp[j - 1] -&gt; dp[j]</span><br>            res = <span class="hljs-built_in">max</span>(res, tmp) <span class="hljs-comment"># max(dp[j - 1], dp[j])</span><br>        <span class="hljs-keyword">return</span> res<br><br></code></pre></td></tr></table></figure><h4 id="寻找两个正序数组的中位数-4gg"><a href="#寻找两个正序数组的中位数-4gg" class="headerlink" title="寻找两个正序数组的中位数 -4gg"></a>寻找两个正序数组的中位数 -4gg</h4><p>时间复杂度为 $$ \log(m+n) $$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findMedianSortedArrays</span>(<span class="hljs-params">self, nums1: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], nums2: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">float</span>:<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_k_min</span>(<span class="hljs-params">nums1, start1, end1, nums2, start2, end2, k</span>):<br>            remain1 = end1 - start1 + <span class="hljs-number">1</span><br>            remain2 = end2 - start2 + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> remain1 == <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">return</span> nums2[start2 + k - <span class="hljs-number">1</span>]<br>            <span class="hljs-keyword">if</span> remain2 == <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">return</span> nums1[start1 + k - <span class="hljs-number">1</span>]<br>            <span class="hljs-keyword">if</span> k == <span class="hljs-number">1</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(nums1[start1], nums2[start2])<br>            i = start1 + <span class="hljs-built_in">min</span>(remain1, k // <span class="hljs-number">2</span>) - <span class="hljs-number">1</span><br>            j = start2 + <span class="hljs-built_in">min</span>(remain2, k // <span class="hljs-number">2</span>) - <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> nums1[i] &lt;= nums2[j]:<br>                <span class="hljs-keyword">return</span> get_k_min(nums1, i+<span class="hljs-number">1</span>, end1, nums2, start2, end2, k - (i - start1 + <span class="hljs-number">1</span>))<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> get_k_min(nums1, start1, end1, nums2, j+<span class="hljs-number">1</span>, end2, k - (j - start2 + <span class="hljs-number">1</span>))<br><br>        m, n = <span class="hljs-built_in">len</span>(nums1), <span class="hljs-built_in">len</span>(nums2)<br>        mid1 = (m + n + <span class="hljs-number">1</span>) // <span class="hljs-number">2</span><br>        mid2 = (m + n + <span class="hljs-number">2</span>) // <span class="hljs-number">2</span><br>        a = get_k_min(nums1, <span class="hljs-number">0</span>, m-<span class="hljs-number">1</span>, nums2, <span class="hljs-number">0</span>, n-<span class="hljs-number">1</span>, mid1)<br>        b = get_k_min(nums1, <span class="hljs-number">0</span>, m-<span class="hljs-number">1</span>, nums2, <span class="hljs-number">0</span>, n-<span class="hljs-number">1</span>, mid2)<br>        <span class="hljs-keyword">return</span> (a + b) / <span class="hljs-number">2</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findMedianSortedArrays</span>(<span class="hljs-params">self, nums1: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], nums2: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">float</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums1) &gt; <span class="hljs-built_in">len</span>(nums2):<br>            <span class="hljs-keyword">return</span> self.findMedianSortedArrays(nums2, nums1)<br>        <span class="hljs-comment">#都是可以通过替换两个数组的名称来保证一定的顺序 num2的长度始终是最长的</span><br><br>        infinty = <span class="hljs-number">2</span>**<span class="hljs-number">40</span>  <span class="hljs-comment"># 代表正无穷</span><br>        m, n = <span class="hljs-built_in">len</span>(nums1), <span class="hljs-built_in">len</span>(nums2)<br>        left, right = <span class="hljs-number">0</span>, m<br>        <span class="hljs-comment"># median1：前一部分的最大值</span><br>        <span class="hljs-comment"># median2：后一部分的最小值</span><br>        median1, median2 = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br><br><br>        <span class="hljs-keyword">while</span> left &lt;= right: <span class="hljs-comment"># 一直循环找到一个最大的i满足A[i−1]≤B[j]</span><br>            <span class="hljs-comment"># 前一部分包含 nums1[0 .. i-1] 和 nums2[0 .. j-1]</span><br>            <span class="hljs-comment"># // 后一部分包含 nums1[i .. m-1] 和 nums2[j .. n-1]</span><br>            i = (left + right) // <span class="hljs-number">2</span><br>            j = (m + n + <span class="hljs-number">1</span>) // <span class="hljs-number">2</span> - i<br><br><br>            <span class="hljs-comment"># nums_im1, nums_i, nums_jm1, nums_j 分别表示 nums1[i-1], nums1[i], nums2[j-1], nums2[j]</span><br>            <span class="hljs-comment"># 当一个数组不出现在前一部分时,对应的值为负无穷,就不会对前一部分的最大值产生影响</span><br>            nums_im1 = (-infinty <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> nums1[i - <span class="hljs-number">1</span>]) <span class="hljs-comment"># 注意写法与java不同</span><br>            <span class="hljs-comment"># 当一个数组不出现在后一部分时,对应的值为正无穷,就不会对后一部分的最小值产生影响</span><br>            nums_i = (infinty <span class="hljs-keyword">if</span> i == m <span class="hljs-keyword">else</span> nums1[i])<br>            nums_jm1 = (-infinty <span class="hljs-keyword">if</span> j == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> nums2[j - <span class="hljs-number">1</span>])<br>            nums_j = (infinty <span class="hljs-keyword">if</span> j == n <span class="hljs-keyword">else</span> nums2[j])<br><br><br>            <span class="hljs-keyword">if</span> nums_im1 &lt;= nums_j:<br>                median1, median2 = <span class="hljs-built_in">max</span>(nums_im1, nums_jm1), <span class="hljs-built_in">min</span>(nums_i, nums_j)<br>                left = i + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                right = i - <span class="hljs-number">1</span><br><br><br>        <span class="hljs-keyword">return</span> (median1 + median2) / <span class="hljs-number">2</span> <span class="hljs-keyword">if</span> (m + n) % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> median1<br><br></code></pre></td></tr></table></figure><h4 id="最长回文串"><a href="#最长回文串" class="headerlink" title="最长回文串"></a>最长回文串</h4><p>识别出最长的回文串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 这个程序复杂度有点高()</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">longestPalindrome</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>        n = <span class="hljs-built_in">len</span>(s)<br>        <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> s<br><br>        max_len = <span class="hljs-number">1</span><br>        begin = <span class="hljs-number">0</span><br>        <span class="hljs-comment"># dp[i][j] 表示 s[i..j] 是否是回文串</span><br>        dp = [[<span class="hljs-literal">False</span>] * n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)] <span class="hljs-comment">#[False]*n 为一个列表中的False的拼接的展示</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            dp[i][i] = <span class="hljs-literal">True</span><br>        <br>        <span class="hljs-comment"># 递推开始</span><br>        <span class="hljs-comment"># 先枚举子串长度</span><br>        <span class="hljs-keyword">for</span> L <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, n + <span class="hljs-number">1</span>):<br>            <span class="hljs-comment"># 枚举左边界，左边界的上限设置可以宽松一些</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                <span class="hljs-comment"># 由 L 和 i 可以确定右边界，即 j - i + 1 = L 得</span><br>                j = L + i - <span class="hljs-number">1</span><br>                <span class="hljs-comment"># 如果右边界越界，就可以退出当前循环</span><br>                <span class="hljs-comment">#i,j 分别为左边界与有边界 在这个循环中,i,j覆盖了所有的值</span><br>                <span class="hljs-keyword">if</span> j &gt;= n:<br>                    <span class="hljs-keyword">break</span><br>                <span class="hljs-comment">#检测的顺序为 按照长度来进行检索</span><br>                <span class="hljs-comment">#对于i开始的,有多少相同的字符串,同时一开始的时候默认是对于任意一个字符,都可以视为回文串,同时对于任何一个串来说,如果首位相同的话,只需要检测里面两个的字符串是否是相同的.</span><br>                <span class="hljs-comment"># 以下开始递归</span><br>                <span class="hljs-keyword">if</span> s[i] != s[j]:<br>                    dp[i][j] = <span class="hljs-literal">False</span> <br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-keyword">if</span> j - i &lt; <span class="hljs-number">3</span>:<br>                        dp[i][j] = <span class="hljs-literal">True</span><br>                    <span class="hljs-keyword">else</span>:<br>                        dp[i][j] = dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]<br>                <br>                <span class="hljs-comment"># 只要 dp[i][L] == true 成立，就表示子串 s[i..L] 是回文，此时记录回文长度和起始位置</span><br>                <span class="hljs-keyword">if</span> dp[i][j] <span class="hljs-keyword">and</span> j - i + <span class="hljs-number">1</span> &gt; max_len:<br>                    max_len = j - i + <span class="hljs-number">1</span><br>                    begin = i<br>        <span class="hljs-keyword">return</span> s[begin:begin + max_len]<br><br><span class="hljs-comment">#这是一个从中心向旁边扩散的算法,只要有就可以向外检测</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">expandAroundCenter</span>(<span class="hljs-params">self, s, left, right</span>):<br>        <span class="hljs-keyword">while</span> left &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> right &lt; <span class="hljs-built_in">len</span>(s) <span class="hljs-keyword">and</span> s[left] == s[right]:<br>            left -= <span class="hljs-number">1</span><br>            right += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> left + <span class="hljs-number">1</span>, right - <span class="hljs-number">1</span><br><span class="hljs-comment"># 这里表示当前的东西判断完成了</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">longestPalindrome</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>        start, end = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):<span class="hljs-comment"># 从字符串的长度出发?</span><br>            left1, right1 = self.expandAroundCenter(s, i, i)<br>            left2, right2 = self.expandAroundCenter(s, i, i + <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">if</span> right1 - left1 &gt; end - start:<br>                start, end = left1, right1<br>            <span class="hljs-keyword">if</span> right2 - left2 &gt; end - start:<br>                start, end = left2, right2<br>        <span class="hljs-keyword">return</span> s[start: end + <span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h3 id="n字形扩散-6-1"><a href="#n字形扩散-6-1" class="headerlink" title="n字形扩散 - 6  (1)"></a>n字形扩散 - 6  (1)</h3><p>将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">convert</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, numRows: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>        <span class="hljs-keyword">if</span> numRows &lt; <span class="hljs-number">2</span>: <span class="hljs-keyword">return</span> s<br>        res = [<span class="hljs-string">&quot;&quot;</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(numRows)]<span class="hljs-comment"># 含有numrow个空字符串的结构 同时相当于做了一个初始化</span><br>        i, flag = <span class="hljs-number">0</span>, -<span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> s:<br>            res[i] += c<br>            <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> i == numRows - <span class="hljs-number">1</span>: flag = -flag<br>            i += flag <span class="hljs-comment"># 通过设置一个flag来控制数字的加入方式</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>.join(res)<br><br></code></pre></td></tr></table></figure><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="插入区间排序-57-2"><a href="#插入区间排序-57-2" class="headerlink" title="插入区间排序 57 - (2)"></a>插入区间排序 57 - (2)</h3><p>对于这个数据,只有重合下面的交集, 以及可以直接放入的数组集, 所以一旦有交集 ,可以更新新的left 与 right 放入新的循环中进行更新</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">insert</span>(<span class="hljs-params">self, intervals: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], newInterval: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>        left, right = newInterval<br>        placed = <span class="hljs-literal">False</span><br>        ans = <span class="hljs-built_in">list</span>() <span class="hljs-comment">#相当于创建了一个新的列表</span><br>        <span class="hljs-keyword">for</span> li, ri <span class="hljs-keyword">in</span> intervals:<br>            <span class="hljs-keyword">if</span> li &gt; right:<br>                <span class="hljs-comment"># 在插入区间的右侧且无交集</span><br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> placed:<br>                    ans.append([left, right])<br>                    placed = <span class="hljs-literal">True</span> <span class="hljs-comment">#完成了放置</span><br>                ans.append([li, ri])<br><br>            <span class="hljs-keyword">elif</span> ri &lt; left:<br>                <span class="hljs-comment"># 在插入区间的左侧且无交集</span><br>                ans.append([li, ri])<br>            <br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-comment"># 与插入区间有交集，计算它们的并集</span><br>                left = <span class="hljs-built_in">min</span>(left, li)<br>                right = <span class="hljs-built_in">max</span>(right, ri)<br>        <br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> placed:<br>            ans.append([left, right])<br>        <span class="hljs-keyword">return</span> ans<br><br></code></pre></td></tr></table></figure><h3 id="三数之和-3"><a href="#三数之和-3" class="headerlink" title="三数之和 - (3)"></a>三数之和 - (3)</h3><p>给你一个整数数组 nums ，判断是否存在三元组 [ nums[i], nums[j], nums[k] ] 满足 i !&#x3D; j、i !&#x3D; k 且 j !&#x3D; k ，同时还满足 nums[i] + nums[j] + nums[k] &#x3D;&#x3D; 0 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#低空间复杂度的算法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">threeSum</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>        <br>        n=<span class="hljs-built_in">len</span>(nums)<br>        res=[]<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">not</span> nums <span class="hljs-keyword">or</span> n&lt;<span class="hljs-number">3</span>):<br>            <span class="hljs-keyword">return</span> []<br>        nums.sort() <span class="hljs-comment">#相当于直接完成升序排列</span><br>        res=[]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">if</span>(nums[i]&gt;<span class="hljs-number">0</span>): <span class="hljs-comment">#?只能保证 i指标是一个用负数的形式取出来的值</span><br>                <span class="hljs-keyword">return</span> res<br>            <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> nums[i]==nums[i-<span class="hljs-number">1</span>]):<span class="hljs-comment">#已经检测过了不需要运行</span><br>                <span class="hljs-keyword">continue</span><br>            L=i+<span class="hljs-number">1</span><br>            R=n-<span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span>(L&lt;R):<br>                <span class="hljs-keyword">if</span>(nums[i]+nums[L]+nums[R]==<span class="hljs-number">0</span>):<br>                    res.append([nums[i],nums[L],nums[R]])<br>                    <span class="hljs-keyword">while</span>(L&lt;R <span class="hljs-keyword">and</span> nums[L]==nums[L+<span class="hljs-number">1</span>]): <span class="hljs-comment">#相同不需要执行</span><br>                        L=L+<span class="hljs-number">1</span><br>                    <span class="hljs-keyword">while</span>(L&lt;R <span class="hljs-keyword">and</span> nums[R]==nums[R-<span class="hljs-number">1</span>]):<br>                        R=R-<span class="hljs-number">1</span><br>                    L=L+<span class="hljs-number">1</span><br>                    R=R-<span class="hljs-number">1</span><br>                <span class="hljs-keyword">elif</span>(nums[i]+nums[L]+nums[R]&gt;<span class="hljs-number">0</span>):<br>                    R=R-<span class="hljs-number">1</span><br>                <span class="hljs-keyword">else</span>:<br>                    L=L+<span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> res<br><span class="hljs-comment"># 说实话, 有点像遍历的直接求出所有情况的算法但实际上采用了一种类似于一层遍历的方法,对于一个数来说,只要排序过后才用一种类似于双指针遍历的方法即可</span><br><br><br><span class="hljs-comment"># 主打一个利用字典排序</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">threeSum</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>        ans = [] <span class="hljs-comment"># 结果列表</span><br>        counts = &#123;&#125; <span class="hljs-comment"># 使用字典存储nums中的元素及其出现次数</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums:<br>            counts[i] = counts.get(i, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span> <span class="hljs-comment"># get是得到 i对应的字典的值, 时间复杂度甚至接近1 </span><br>        <br>        nums = <span class="hljs-built_in">sorted</span>(counts) <span class="hljs-comment"># sorted 是保留副本的排序方法,sort是直接在原来的字典上面排序</span><br>        <span class="hljs-keyword">for</span> i, num <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):<br>            <span class="hljs-keyword">if</span> counts[num] &gt; <span class="hljs-number">1</span>: <span class="hljs-comment"># 如果当前元素的出现次数大于1</span><br>                <span class="hljs-keyword">if</span> num == <span class="hljs-number">0</span>: <span class="hljs-comment"># 处理特殊情况0</span><br>                    <span class="hljs-keyword">if</span> counts[num] &gt; <span class="hljs-number">2</span>:  <br>                        ans.append([<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]) <span class="hljs-comment"># 如果0出现三次及以上,添加[0, 0, 0]到结果</span><br>                        <span class="hljs-keyword">continue</span><br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-keyword">if</span> -num * <span class="hljs-number">2</span> <span class="hljs-keyword">in</span> counts: <span class="hljs-comment"># 如果当前元素的相反数的两倍也在counts中</span><br>                        ans.append([num, num, -<span class="hljs-number">2</span> * num]) <span class="hljs-comment"># 添加[num, num, -2*num]到结果</span><br><br>            <br>            <span class="hljs-keyword">if</span> num &lt; <span class="hljs-number">0</span>: <span class="hljs-comment"># 只需要考虑负数的情况</span><br>                two_sum = -num <span class="hljs-comment"># two_sum表示除num外另外两个元素的和</span><br>                left = bisect.bisect_left(nums, (two_sum - nums[-<span class="hljs-number">1</span>]), i + <span class="hljs-number">1</span>) <br>                <span class="hljs-comment"># 使用二分查找找到合适的左边界下标</span><br>                <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> nums[left: bisect.bisect_right(nums, (two_sum // <span class="hljs-number">2</span>), left)]:<br>                    <span class="hljs-comment"># 在合适范围内遍历</span><br>                    k = two_sum - j  <br>                    <span class="hljs-keyword">if</span> k <span class="hljs-keyword">in</span> counts <span class="hljs-keyword">and</span> k != j: <span class="hljs-comment"># 如果找到符合的k</span><br>                        ans.append([num, j, k]) <span class="hljs-comment"># 添加到结果</span><br><br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h3 id="三数之和接近target"><a href="#三数之和接近target" class="headerlink" title="三数之和接近target"></a>三数之和接近target</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">threeSumClosest</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        nums.sort()<br>        n = <span class="hljs-built_in">len</span>(nums)<br>        min_diff = inf<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n - <span class="hljs-number">2</span>):<br>            x = nums[i]<br>            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">and</span> x == nums[i - <span class="hljs-number">1</span>]:<br>                <span class="hljs-keyword">continue</span>  <span class="hljs-comment"># 优化三 排序后的常见的优化方法, 如果排序后,有两个数相互临近则必不可能输出正确的值</span><br><br>            <span class="hljs-comment"># 优化一 如果执行到了这个值,同时后三个数之和比target大 那么这里是最接近的值</span><br>            s = x + nums[i + <span class="hljs-number">1</span>] + nums[i + <span class="hljs-number">2</span>]<br>            <span class="hljs-keyword">if</span> s &gt; target:  <span class="hljs-comment"># 后面无论怎么选，选出的三个数的和不会比 s 还小</span><br>                <span class="hljs-keyword">if</span> s - target &lt; min_diff:<br>                    ans = s  <span class="hljs-comment"># 由于下一行直接 break，这里无需更新 min_diff</span><br>                <span class="hljs-keyword">break</span><br><br>            <span class="hljs-comment"># 优化二</span><br>            s = x + nums[-<span class="hljs-number">2</span>] + nums[-<span class="hljs-number">1</span>]<br>            <span class="hljs-keyword">if</span> s &lt; target:  <span class="hljs-comment"># x 加上后面任意两个数都不超过 s，所以下面的双指针就不需要跑了</span><br>                <span class="hljs-keyword">if</span> target - s &lt; min_diff:<br>                    min_diff = target - s<br>                    ans = s<br>                <span class="hljs-keyword">continue</span><br><br>            <span class="hljs-comment"># 双指针 典中典之双指针</span><br>            j, k = i + <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span> j &lt; k:<br>                s = x + nums[j] + nums[k]<br>                <span class="hljs-keyword">if</span> s == target:<br>                    <span class="hljs-keyword">return</span> s<br>                <span class="hljs-keyword">if</span> s &gt; target:<br>                    <span class="hljs-keyword">if</span> s - target &lt; min_diff:  <span class="hljs-comment"># s 与 target 更近</span><br>                        min_diff = s - target<br>                        ans = s<br>                    k -= <span class="hljs-number">1</span><br>                <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># s &lt; target</span><br>                    <span class="hljs-keyword">if</span> target - s &lt; min_diff:  <span class="hljs-comment"># s 与 target 更近</span><br>                        min_diff = target - s<br>                        ans = s<br>                    j += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> ans<br><br></code></pre></td></tr></table></figure><h3 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a>四数之和</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">fourSum</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>        quadruplets = <span class="hljs-built_in">list</span>()<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> nums <span class="hljs-keyword">or</span> <span class="hljs-built_in">len</span>(nums) &lt; <span class="hljs-number">4</span>:<br>            <span class="hljs-keyword">return</span> quadruplets<br>        <br>        nums.sort()<br>        length = <span class="hljs-built_in">len</span>(nums)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(length - <span class="hljs-number">3</span>):<br>            <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> nums[i] == nums[i - <span class="hljs-number">1</span>]:<br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">if</span> nums[i] + nums[i + <span class="hljs-number">1</span>] + nums[i + <span class="hljs-number">2</span>] + nums[i + <span class="hljs-number">3</span>] &gt; target:<br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">if</span> nums[i] + nums[length - <span class="hljs-number">3</span>] + nums[length - <span class="hljs-number">2</span>] + nums[length - <span class="hljs-number">1</span>] &lt; target:<br>                <span class="hljs-keyword">continue</span><br>            <br>            <span class="hljs-comment">#简单的优化 </span><br><br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i + <span class="hljs-number">1</span>, length - <span class="hljs-number">2</span>):<br>                <span class="hljs-keyword">if</span> j &gt; i + <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> nums[j] == nums[j - <span class="hljs-number">1</span>]:<br>                    <span class="hljs-keyword">continue</span><br>                <span class="hljs-keyword">if</span> nums[i] + nums[j] + nums[j + <span class="hljs-number">1</span>] + nums[j + <span class="hljs-number">2</span>] &gt; target:<br>                    <span class="hljs-keyword">break</span><br>                <span class="hljs-keyword">if</span> nums[i] + nums[j] + nums[length - <span class="hljs-number">2</span>] + nums[length - <span class="hljs-number">1</span>] &lt; target:<br>                    <span class="hljs-keyword">continue</span><br>                left, right = j + <span class="hljs-number">1</span>, length - <span class="hljs-number">1</span><br>                <span class="hljs-keyword">while</span> left &lt; right:<br>                    total = nums[i] + nums[j] + nums[left] + nums[right]<br>                    <span class="hljs-keyword">if</span> total == target:<br>                        quadruplets.append([nums[i], nums[j], nums[left], nums[right]])<br>                        <span class="hljs-keyword">while</span> left &lt; right <span class="hljs-keyword">and</span> nums[left] == nums[left + <span class="hljs-number">1</span>]:<br>                            left += <span class="hljs-number">1</span><br>                        left += <span class="hljs-number">1</span><br>                        <span class="hljs-keyword">while</span> left &lt; right <span class="hljs-keyword">and</span> nums[right] == nums[right - <span class="hljs-number">1</span>]:<br>                            right -= <span class="hljs-number">1</span><br>                        right -= <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">elif</span> total &lt; target:<br>                        left += <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">else</span>:<br>                        right -= <span class="hljs-number">1</span><br>        <br>        <span class="hljs-keyword">return</span> quadruplets<br></code></pre></td></tr></table></figure><h3 id="字母异位词分组"><a href="#字母异位词分组" class="headerlink" title="字母异位词分组"></a>字母异位词分组</h3><p>给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">groupAnagrams</span>(<span class="hljs-params">self, strs: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]]:<br>        a=&#123;&#125;<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> strs:<br>            i_=<span class="hljs-string">&#x27;&#x27;</span>.join(<span class="hljs-built_in">sorted</span>(i))<span class="hljs-comment">#内部的字符串排序??? 有点抽象了</span><br>            <span class="hljs-keyword">if</span> i_ <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> a:<br>                a[i_]=[i]<br>            <span class="hljs-keyword">else</span>:<br>                a[i_].append(i) <span class="hljs-comment">#存入i 合理的, 但是抽象</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>(a.values())<br><br></code></pre></td></tr></table></figure><h3 id="合并相关的区间"><a href="#合并相关的区间" class="headerlink" title="合并相关的区间"></a>合并相关的区间</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">merge</span>(<span class="hljs-params">self, intervals: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br><br>        intervals.sort(key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">0</span>]) <span class="hljs-comment">#排序的关键函数 这里也就是把left进行排列</span><br><br>        merged = []<br>        <span class="hljs-keyword">for</span> interval <span class="hljs-keyword">in</span> intervals:<br>            <span class="hljs-comment"># 如果列表为空，或者当前区间与上一区间不重合，直接添加</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> merged <span class="hljs-keyword">or</span> merged[-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] &lt; interval[<span class="hljs-number">0</span>]:<br>                merged.append(interval)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-comment"># 否则的话，我们就可以与上一区间进行合并</span><br>                merged[-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(merged[-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>], interval[<span class="hljs-number">1</span>])<br><br>        <span class="hljs-keyword">return</span> merged<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nlp_paper</title>
    <link href="/2023/08/26/nlp-paper/"/>
    <url>/2023/08/26/nlp-paper/</url>
    
    <content type="html"><![CDATA[<h1 id="paper-read"><a href="#paper-read" class="headerlink" title="paper-read"></a>paper-read</h1><h2 id="A-Survey-on-Large-Language-Model-based-Autonomous-Agents"><a href="#A-Survey-on-Large-Language-Model-based-Autonomous-Agents" class="headerlink" title="A Survey on Large Language Model based Autonomous Agents"></a>A Survey on Large Language Model based Autonomous Agents</h2><h4 id="Learning-from-Interactive-Human-Feedback"><a href="#Learning-from-Interactive-Human-Feedback" class="headerlink" title="Learning from Interactive Human Feedback"></a>Learning from Interactive Human Feedback</h4>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>NLP&amp;&amp;LLM</title>
    <link href="/2023/08/20/NLP/"/>
    <url>/2023/08/20/NLP/</url>
    
    <content type="html"><![CDATA[<h2 id="BASE"><a href="#BASE" class="headerlink" title="BASE"></a>BASE</h2><p>参考链接 <a href="https://huggingface.co/learn/nlp-course/">NLP_course</a></p><h3 id="unigram-tokenization"><a href="#unigram-tokenization" class="headerlink" title="unigram tokenization"></a>unigram tokenization</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">encode_word</span>(<span class="hljs-params">word, model</span>):<br>    best_segmentations = [&#123;<span class="hljs-string">&quot;start&quot;</span>: <span class="hljs-number">0</span>, <span class="hljs-string">&quot;score&quot;</span>: <span class="hljs-number">1</span>&#125;] + [<br>        &#123;<span class="hljs-string">&quot;start&quot;</span>: <span class="hljs-literal">None</span>, <span class="hljs-string">&quot;score&quot;</span>: <span class="hljs-literal">None</span>&#125; <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(word))<br>    ]<br>    <span class="hljs-comment">#至少每一种字长都有留下来对应的一个值.同时在位次上对应END,里面的start对应了在这个END中,在哪里有最好的分词的方法.</span><br>    <span class="hljs-keyword">for</span> start_idx <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(word)):<br>        <span class="hljs-comment"># This should be properly filled by the previous steps of the loop</span><br>        best_score_at_start = best_segmentations[start_idx][<span class="hljs-string">&quot;score&quot;</span>]<br>        <span class="hljs-keyword">for</span> end_idx <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(start_idx + <span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(word) + <span class="hljs-number">1</span>):<br>            token = word[start_idx:end_idx] <span class="hljs-comment"># toke截取了一组值,之后通过查表进行比较</span><br>            <span class="hljs-keyword">if</span> token <span class="hljs-keyword">in</span> model <span class="hljs-keyword">and</span> best_score_at_start <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                score = model[token] + best_score_at_start<br>                <span class="hljs-comment"># If we have found a better segmentation ending at end_idx, we update</span><br>                <span class="hljs-keyword">if</span> (<br>                    best_segmentations[end_idx][<span class="hljs-string">&quot;score&quot;</span>] <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span><br>                    <span class="hljs-keyword">or</span> best_segmentations[end_idx][<span class="hljs-string">&quot;score&quot;</span>] &gt; score<br>                ):<br>                <span class="hljs-comment">#这里取的是-log相当于是一个递减的函数,如果频率高,反而得到的值越低,所以这里选择高频率的留下,</span><br>                <span class="hljs-comment">#关于继承前面的值,这里的含义指的是:start end都含有一定的值,start的分词+新增的词块频率够高的情况才更新END的模块</span><br>                <span class="hljs-comment">#下面对应了两种情况,一种是后续没有end_idx直接打上标签 另一种是在当前的start + 增的 比后续的低则更改??</span><br>                    best_segmentations[end_idx] = &#123;<span class="hljs-string">&quot;start&quot;</span>: start_idx, <span class="hljs-string">&quot;score&quot;</span>: score&#125;<br><br>    segmentation = best_segmentations[-<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">if</span> segmentation[<span class="hljs-string">&quot;score&quot;</span>] <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-comment"># We did not find a tokenization of the word -&gt; unknown</span><br>        <span class="hljs-keyword">return</span> [<span class="hljs-string">&quot;&lt;unk&gt;&quot;</span>], <span class="hljs-literal">None</span><br><br>    score = segmentation[<span class="hljs-string">&quot;score&quot;</span>]<br>    start = segmentation[<span class="hljs-string">&quot;start&quot;</span>]<br>    end = <span class="hljs-built_in">len</span>(word)<br>    tokens = []<br>    <span class="hljs-keyword">while</span> start != <span class="hljs-number">0</span>:<br>        tokens.insert(<span class="hljs-number">0</span>, word[start:end])<br>        next_start = best_segmentations[start][<span class="hljs-string">&quot;start&quot;</span>]<br>        end = start<br>        start = next_start<br>    tokens.insert(<span class="hljs-number">0</span>, word[start:end])<br>    <span class="hljs-keyword">return</span> tokens, score<br><span class="hljs-comment"># 但是为什么是最后的一个?</span><br></code></pre></td></tr></table></figure><h2 id="MAIN-NLP-TASKS"><a href="#MAIN-NLP-TASKS" class="headerlink" title="MAIN NLP TASKS"></a>MAIN NLP TASKS</h2><h3 id="Token-classification"><a href="#Token-classification" class="headerlink" title="Token classification"></a>Token classification</h3><h4 id="preparing-the-data"><a href="#preparing-the-data" class="headerlink" title="preparing the data"></a>preparing the data</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> datasets <span class="hljs-keyword">import</span> load_dataset<br>raw_datasets = load_dataset(<span class="hljs-string">&quot;conll2003&quot;</span>)<br><br><span class="hljs-comment"># 数据形式</span><br><br>DatasetDict(&#123;<br>    train: Dataset(&#123;<br>        features: [<span class="hljs-string">&#x27;chunk_tags&#x27;</span>, <span class="hljs-string">&#x27;id&#x27;</span>, <span class="hljs-string">&#x27;ner_tags&#x27;</span>, <span class="hljs-string">&#x27;pos_tags&#x27;</span>, <span class="hljs-string">&#x27;tokens&#x27;</span>],<br>        num_rows: <span class="hljs-number">14041</span><br>    &#125;)<br>    validation: Dataset(&#123;<br>        features: [<span class="hljs-string">&#x27;chunk_tags&#x27;</span>, <span class="hljs-string">&#x27;id&#x27;</span>, <span class="hljs-string">&#x27;ner_tags&#x27;</span>, <span class="hljs-string">&#x27;pos_tags&#x27;</span>, <span class="hljs-string">&#x27;tokens&#x27;</span>],<br>        num_rows: <span class="hljs-number">3250</span><br>    &#125;)<br>    test: Dataset(&#123;<br>        features: [<span class="hljs-string">&#x27;chunk_tags&#x27;</span>, <span class="hljs-string">&#x27;id&#x27;</span>, <span class="hljs-string">&#x27;ner_tags&#x27;</span>, <span class="hljs-string">&#x27;pos_tags&#x27;</span>, <span class="hljs-string">&#x27;tokens&#x27;</span>],<br>        num_rows: <span class="hljs-number">3453</span><br>    &#125;)<br>&#125;)<br><span class="hljs-comment">#the last column is called tokens, but it contains words in the sense that these are pre-tokenized inputs that still need to go through the tokenizer for subword tokenization</span><br><br><span class="hljs-comment"># 数据形式</span><br>ner_feature = raw_datasets[<span class="hljs-string">&quot;train&quot;</span>].features[<span class="hljs-string">&quot;ner_tags&quot;</span>]<br><br><span class="hljs-type">Sequence</span>(feature=ClassLabel(num_classes=<span class="hljs-number">9</span>, names=[<span class="hljs-string">&#x27;O&#x27;</span>, <span class="hljs-string">&#x27;B-PER&#x27;</span>, <span class="hljs-string">&#x27;I-PER&#x27;</span>, <span class="hljs-string">&#x27;B-ORG&#x27;</span>, <span class="hljs-string">&#x27;I-ORG&#x27;</span>, <span class="hljs-string">&#x27;B-LOC&#x27;</span>, <span class="hljs-string">&#x27;I-LOC&#x27;</span>, <span class="hljs-string">&#x27;B-MISC&#x27;</span>, <span class="hljs-string">&#x27;I-MISC&#x27;</span>], names_file=<span class="hljs-literal">None</span>, <span class="hljs-built_in">id</span>=<span class="hljs-literal">None</span>), length=-<span class="hljs-number">1</span>, <span class="hljs-built_in">id</span>=<span class="hljs-literal">None</span>)<br><br><span class="hljs-comment"># 表示这里的训练队列的类型</span><br></code></pre></td></tr></table></figure><p>解构数据表示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><br>words = raw_datasets[<span class="hljs-string">&quot;train&quot;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&quot;tokens&quot;</span>]<br>labels = raw_datasets[<span class="hljs-string">&quot;train&quot;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&quot;ner_tags&quot;</span>]<br>line1 = <span class="hljs-string">&quot;&quot;</span><br>line2 = <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">for</span> word, label <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(words, labels):<span class="hljs-comment">#不仅取出了两个列表中的元素,同时把这两个对应的数组压缩成元组</span><br>    full_label = label_names[label]<br>    max_length = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">len</span>(word), <span class="hljs-built_in">len</span>(full_label))<br>    line1 += word + <span class="hljs-string">&quot; &quot;</span> * (max_length - <span class="hljs-built_in">len</span>(word) + <span class="hljs-number">1</span>)<br>    line2 += full_label + <span class="hljs-string">&quot; &quot;</span> * (max_length - <span class="hljs-built_in">len</span>(full_label) + <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h4 id="数据加工"><a href="#数据加工" class="headerlink" title="数据加工"></a>数据加工</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer<br><br>model_checkpoint = <span class="hljs-string">&quot;bert-base-cased&quot;</span><br>tokenizer = AutoTokenizer.from_pretrained(model_checkpoint)<br><br>inputs = tokenizer(raw_dataset[<span class="hljs-string">&quot;train&quot;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&quot;tokens&quot;</span>],is_split_into_words = <span class="hljs-literal">True</span>)<br><br>inputs.word_ids()<span class="hljs-comment">#可以正确的对齐每一个tokens的单词的位置</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#这个函数相当于分裂同时打上标签</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">align_labels_with_tokens</span>(<span class="hljs-params">labels,word_ids</span>):<br>    <span class="hljs-comment">#labels是来自于ner_tags</span><br>    new_labels = []<br>    current_word = <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">for</span> word_id <span class="hljs-keyword">in</span> word_ids:<br>        <span class="hljs-keyword">if</span> word_id != current_word:<span class="hljs-comment">#区分是否是一个新的单词</span><br>            current_word = word_id<br>            label = -<span class="hljs-number">100</span> <span class="hljs-keyword">if</span> word_id <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> labels[word_id]<br>            new_labels.append(label)<span class="hljs-comment">#放入新的label</span><br>        <span class="hljs-keyword">elif</span> word_id = <span class="hljs-literal">None</span>:<br>            new_labels.append(-<span class="hljs-number">100</span>)<br>        <span class="hljs-keyword">else</span>:<br>            label = labels[word_id]<span class="hljs-comment">#是在当前的labels中</span><br>            <span class="hljs-keyword">if</span> label % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>:<br>                label += <span class="hljs-number">1</span> <span class="hljs-comment">#相当于把B中的值转换为I,如果是同一个单词的情况下</span><br>            new_labels.append(label)<br>    <span class="hljs-keyword">return</span> new_labels<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">tokenize_and_align_labels</span>(<span class="hljs-params">examples</span>):<br>    tokenized_inputs = tokenizer(examples[<span class="hljs-string">&quot;tokens&quot;</span>],truncation = <span class="hljs-literal">True</span>, is_split_into_words =<span class="hljs-literal">True</span>)<br>    all_labels = example[<span class="hljs-string">&quot;ner_tags&quot;</span>]<br>    new_labels = []<br>    <span class="hljs-keyword">for</span> i,labels <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(all_labels):<br>        word_ids = tokenized_inputs.word_ids(i)<br>        new_labels.append(align_labels_with_tokens(labels,word_ids))<br>    <br>    tokenized_input[<span class="hljs-string">&quot;labels&quot;</span>] = new_labels<br>    <span class="hljs-keyword">return</span> tokenized_inputs<br><br><span class="hljs-comment">#这里基本相当于是在下面进行了调用,但是这里仍然没有完成把所有的对齐附带上padding</span><br><br><span class="hljs-comment">#以下完成数据集的训练</span><br>tokenized_datasets = raw_datasets.<span class="hljs-built_in">map</span>(<br>    tokenize_and_align_labels,<span class="hljs-comment">#这里的原理应该相当于直接把这个raw数据集传入进去,然后直接依照相关的函数进行输出</span><br>    batched = <span class="hljs-literal">True</span>,<br>    remove_columns = raw_datasets[<span class="hljs-string">&quot;train&quot;</span>].column_names,<span class="hljs-comment">#这里相当于把训练后的这一列删除掉</span><br>)<br><br></code></pre></td></tr></table></figure><h4 id="Fine-tuning-the-modle-with-trainer-API"><a href="#Fine-tuning-the-modle-with-trainer-API" class="headerlink" title="Fine-tuning the modle with trainer API"></a>Fine-tuning the modle with trainer API</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> DataCollatorForTokenClassification<br>data_collator = DataClollatorForTokenClassification(tokenizer = tokenizer)<br><span class="hljs-comment">#这里没有对齐的值默认打上了-100的标签</span><br></code></pre></td></tr></table></figure><h4 id="Metrics-度量指标"><a href="#Metrics-度量指标" class="headerlink" title="Metrics 度量指标"></a>Metrics 度量指标</h4><p>利用seqeval进行度量该指标</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> evalutate<br>metric = evaluate.load(<span class="hljs-string">&quot;seqeval&quot;</span>)<br><br>labels = raw_datasets[<span class="hljs-string">&quot;train&quot;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&quot;ner_tags&quot;</span>]<br>labels = [label_names[i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> labels]<br><span class="hljs-comment">#这里相当于把原先的偏移寻址转换成了正常的可读入字符串的形式</span><br>predictions = labels.copy()<br>predictions[<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;0&quot;</span><br>metric.compute(predictions= [predictions],reference = [labels])<br></code></pre></td></tr></table></figure><p>计算度量函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">compute_metrcis</span>(<span class="hljs-params">eval_preds</span>):<br>    logis,labels = eval_preds<br>    predictions = np.argmax(logits,axis =-<span class="hljs-number">1</span>)<span class="hljs-comment">#true 是真的值,prediction是一个以训练结果导出来的值</span><br>    true_labels = [[label_namse[l] <span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> label <span class="hljs-keyword">if</span> l != -<span class="hljs-number">100</span>] <span class="hljs-keyword">for</span> label <span class="hljs-keyword">in</span> labels] <span class="hljs-comment"># 啥?</span><br>    true_predictions = [ [label_name[p] <span class="hljs-keyword">for</span> (p,l) <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(prediction,label) <span class="hljs-keyword">if</span> l != -<span class="hljs-number">100</span>] <span class="hljs-keyword">for</span> prediction,label <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(predictions,labels)]<br>    all_metrics = metrci.compute(predictions = ture_predictions, references = true_labels)<br><br></code></pre></td></tr></table></figure><h4 id="defining-the-Model"><a href="#defining-the-Model" class="headerlink" title="defining the Model"></a>defining the Model</h4><p>设置一个相反的字典</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">id2label = &#123;i:label <span class="hljs-keyword">for</span> i, label <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(label_names)&#125;<br>lable2id = &#123;v,k <span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> id2label.items()&#125;<br></code></pre></td></tr></table></figure><p>在传入相关的模型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoModelForTokenClassification<br>model = AutoModelForTokenClassification.from_pretrained(<br>    model_checkpoint,<br>    id2label = id2label<br>    label2id = label2id<br>)<br></code></pre></td></tr></table></figure><h4 id="Fine-tuning-the-model"><a href="#Fine-tuning-the-model" class="headerlink" title="Fine-tuning the model"></a>Fine-tuning the model</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> huggingface_hub <span class="hljs-keyword">import</span> notebook_login<br>notebook_login()<br><span class="hljs-comment">#调用训练参数</span><br><span class="hljs-keyword">from</span> transformes <span class="hljs-keyword">import</span> TrainingArguments<br>args = TrainingArguments(<br>    <span class="hljs-string">&quot;bert-finetune-ner&quot;</span>,<br>    evaluation_strategy = <span class="hljs-string">&quot;epoch&quot;</span>,<br>    save_strategy = <span class="hljs-string">&quot;epoch&quot;</span>,<br>    learning_rate = <span class="hljs-number">2e05</span>,<br>    num_train_epochs= <span class="hljs-number">3</span><br>    weight_decay= <span class="hljs-number">0.01</span>.<br>    push_to_hub = <span class="hljs-literal">True</span>,<br>)<br><span class="hljs-comment">#构建一个trainer</span><br><span class="hljs-keyword">from</span>  transformers <span class="hljs-keyword">import</span> Trainer<br><br>trainer = Trainer(<br>    model = model,<br>    args =args,<br>    train_dataset = tokenized_datasets[<span class="hljs-string">&quot;train&quot;</span>],<br>    eval_dataset = tokenized_datasets[<span class="hljs-string">&quot;validation&quot;</span>],<br>    data_collator = data_collator,<br>    compyte_metrics= compute_metrics,<br>    tokenizer = tokenizer,<br>)<br>trainer.train()<br>trainer.push_to_hub(commit_message= <span class="hljs-string">&quot;Training complete&quot;</span>)<br></code></pre></td></tr></table></figure><p>以上的模型在每一次训练的时候,都会上传到hub中</p><h4 id="传统的训练流程举例"><a href="#传统的训练流程举例" class="headerlink" title="传统的训练流程举例"></a>传统的训练流程举例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> DataLoader<br><br>train_dataloader = DataLoader(<br>    tokenized_datasets[<span class="hljs-string">&quot;train&quot;</span>],<br>    shuffle = <span class="hljs-literal">True</span>,<br>    collate_fn = data_collator,<br>    batch_size = <span class="hljs-number">8</span>,<br><br>)<br>eval_dataloader = DataLoader(<br>    tokenized_datasets[<span class="hljs-string">&quot;validation&quot;</span>],<br>    collate_fn= data_collator,<br>    batch_size = <span class="hljs-number">8</span><br>)<br><br><span class="hljs-comment">#构建模型</span><br><br>model = AutoModelForTokenXlassification.from_pretrained(<br>    model_checkpoint,<br>    id2label = id2label,<br>    label2id  = label2id,<br>)<br><br><span class="hljs-keyword">from</span> torch.optim <span class="hljs-keyword">import</span> AdamW<br>optimizer = AdamW(model.parameters(),lr= <span class="hljs-number">2e-5</span>)<br><br><span class="hljs-comment">#加速器模块</span><br><br><span class="hljs-keyword">from</span> accelerate <span class="hljs-keyword">import</span> Accelerator<br>accelerator = Accelerator()<br>modle,optimizer,train_dataloader,eval_dataloader = accelerator.prepare(<br>    modle,optimizer,train_dataloader,eval_dataloader<br>)<br><br><span class="hljs-comment">#???</span><br><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> get_scheduler<br>num_train_epochs = <span class="hljs-number">3</span><br>num_update_steps_per_epoch = <span class="hljs-built_in">len</span>(train_dataloader)<br>num_training_steps = num_train_epochs * num_update_steps_per_epoch <span class="hljs-comment">#全部训练完的epoch</span><br>lr_scheduler = get_scheduler(<br>    <span class="hljs-string">&quot;linear&quot;</span>,<br>    optimizer = optimizer.<br>    num_warmup_steps = <span class="hljs-number">0</span>,<br>    num_training_steps = num_training_steps<br>)<br><br></code></pre></td></tr></table></figure><h4 id="上传到仓库"><a href="#上传到仓库" class="headerlink" title="上传到仓库"></a>上传到仓库</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> huggingface_hub <span class="hljs-keyword">import</span> Repository,get_full_repo_name<br>model_name = <span class="hljs-string">&quot;bert-finetune-ner-accelerate&quot;</span><br>repo_name = get_full_repo_name(model_name)<span class="hljs-comment">#加上原来的地址.</span><br><br></code></pre></td></tr></table></figure><h4 id="Train-loop"><a href="#Train-loop" class="headerlink" title="Train loop"></a>Train loop</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">postprocess</span>(<span class="hljs-params">predictions,labels</span>):<br>    predictions = predictions.detach().cpu().clone().numpy()<br>    labels = labels.detach().cpu().clone().numpy()<br>    <span class="hljs-comment">#从GPU中拷贝数据并转换为numpy数据</span><br><br>    true_labels = [ [label_names[l] <span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> label <span class="hljs-keyword">if</span> l != <span class="hljs-number">100</span>] <span class="hljs-keyword">for</span> label <span class="hljs-keyword">in</span> labels]<br>    true_predictions = [ [label_names[p] <span class="hljs-keyword">for</span> (p,l) <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(prediction,label) <span class="hljs-keyword">if</span> l != -<span class="hljs-number">100</span>]<br>    <span class="hljs-keyword">for</span> prediction , label <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(predictions, labels)]<br>    <span class="hljs-keyword">return</span> true_labels,true_predictions<br><br><span class="hljs-comment">#训练中</span><br><span class="hljs-keyword">from</span> tqdm.auto <span class="hljs-keyword">import</span> tqdm<br><span class="hljs-keyword">import</span> torch<br>progress_bar = tqdm((<span class="hljs-built_in">range</span>(num_training_steps)))<br><br><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_train_epochs):<br>    model.train()<br>    <span class="hljs-keyword">for</span> batch <span class="hljs-keyword">in</span> train_dataloader:<br>        outputs = model(**batch)<br>        loss = outputs.loss<br>        accelerator.backward(loss)<br>        optimizer.step()<br>        lr_scheduler.step()<br>        optimizer.zero_grad()<br>        progress_bar.update(<span class="hljs-number">1</span>)<br>    <br>    model.<span class="hljs-built_in">eval</span>()<br>    <span class="hljs-keyword">for</span> batch <span class="hljs-keyword">in</span> eval_dataloader:<br>        <span class="hljs-keyword">with</span> torch.no_grad():<br>            outputs = model(**batch)<br>        <br>        predictions = outputs/logits.argmax(dim=-<span class="hljs-number">1</span>)<br>        labels = batch[<span class="hljs-string">&quot;labels&quot;</span>]<br></code></pre></td></tr></table></figure><p>部分跳过🤣👉🏻🤡</p><h3 id="Fine-tuning-a-masked-language-model"><a href="#Fine-tuning-a-masked-language-model" class="headerlink" title="Fine-tuning a masked language model"></a>Fine-tuning a masked language model</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoModelForMaskedLM<br>model_checkpoint = <span class="hljs-string">&quot;distilbert-base-uncased&quot;</span><br>model = AutoModelForMaskedLM.from_pretrained(model_Checkpoint)<br><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer<br>tokenizer = AutoTokenizer.from_pretrained(model_checkpoint)<br><br><span class="hljs-keyword">import</span> torch<br>inputs = tokenizer(text,return_tensors= <span class="hljs-string">&quot;pt&quot;</span>)<span class="hljs-comment">#按照pytorch张量输出</span><br>token_logits = modle(**inputs).logits<br>mask_token_index = torch.where(inputs[input_ids]== tokenizer.mask_token_id)[<span class="hljs-number">1</span>]<br>mask_token_logits = token_logits[<span class="hljs-number">0</span>,mask_token_index,:]<br>top_5_token = torch.topk(mask_token_logits,<span class="hljs-number">5</span>,dim = <span class="hljs-number">1</span>).indices[<span class="hljs-number">0</span>],tolist()<br><br><span class="hljs-keyword">from</span> datasets <span class="hljs-keyword">import</span> load_dataset<br><br>imdb_dataset = load_dataset(<span class="hljs-string">&quot;imdb&quot;</span>)<br>sample = imdb_dataset[<span class="hljs-string">&quot;train&quot;</span>].shuffle(seed=<span class="hljs-number">42</span>).select(<span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>))<br><span class="hljs-comment">#注意可以通过数据集的特定部分的.shuffle来选择打乱数据集</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">tokenize_function</span>(<span class="hljs-params">examples</span>):<br>    result = tokenizer(examples[<span class="hljs-string">&quot;text&quot;</span>])<br>    <span class="hljs-keyword">if</span> tokenizer.is_fast:<br>        result[<span class="hljs-string">&quot;word_ids&quot;</span>] = [result.word_ids(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(result[<span class="hljs-string">&quot;input_ids&quot;</span>]))] <span class="hljs-comment">#word_ids相当于分词器映射到了第几个单词上面 这里相当于对于不同的句子组建立了不同的值</span><br>    <span class="hljs-keyword">return</span> result<br><br>tokenizer.model_max_length <span class="hljs-comment"># 分词器最大的文本容纳量</span><br><br><span class="hljs-comment">#连锁</span><br>tokenized_samples = tokenized_datasets[<span class="hljs-string">&quot;train&quot;</span>][:<span class="hljs-number">3</span>]<br><span class="hljs-keyword">for</span> idx,sample <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(tokenized_samples[<span class="hljs-string">&quot;input_ids&quot;</span>]):<br>    <span class="hljs-built_in">print</span>(f <span class="hljs-string">&quot;&gt;&gt;&#123;ids&#125;&quot;</span>)<br><br><br>concatenated_examples = &#123;<br>    <span class="hljs-comment">#以下相当于把多个不同的列表合成为一个共同的列表</span><br>    k:<span class="hljs-built_in">sum</span>(tokenized_samples[k],[]) <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> examples.keys()<span class="hljs-comment">#生成字典的键的值</span><br>&#125;<span class="hljs-comment"># k是一系列的键</span><br>total_length = <span class="hljs-built_in">len</span>(concatenated_examples[<span class="hljs-string">&quot;input_ids&quot;</span>]) <span class="hljs-comment">#951</span><br><br>Chunk = &#123;<br>    k:[t[i:i+chunk_size] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,total_length,chunk_size)]<br>    <span class="hljs-keyword">for</span> k ,t <span class="hljs-keyword">in</span> concatenated_exampls.items() <span class="hljs-comment">#相当于元素的整合再按照chunk_size的切割</span><br>&#125;<br><br><br><br></code></pre></td></tr></table></figure><p><strong>同时对于最后一个chunk出现的不均匀的情况,采用直接填充,或者直接丢弃的方法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">group_texts</span>(<span class="hljs-params">examples</span>):<br>    concatenated_examples = &#123;k:<span class="hljs-built_in">sum</span>(examples[k],[]) <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> examples.keys()&#125;<br>    total_length = <span class="hljs-built_in">len</span>(concatenated_examples[<span class="hljs-built_in">list</span>(examples.keys())[<span class="hljs-number">0</span>]])<br>    total_length = (total_length // chunk_size) *chunk_size<br><br>    result = &#123;<br>        k:[t[i:i+chunk_size]<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,total_legth,chunk_size)] <span class="hljs-keyword">for</span> k,t inconcatenated_examples.items()<br>    &#125;<br><br>    result[<span class="hljs-string">&quot;labels&quot;</span>]= result[<span class="hljs-string">&quot;input_ids&quot;</span>].copy()<br>    <span class="hljs-keyword">return</span> result<br><br>lm_datasets = tokenzied_datasets.<span class="hljs-built_in">map</span>(group_texts,batched = <span class="hljs-literal">True</span>)    <br><br></code></pre></td></tr></table></figure><h4 id="Fine-tuning-DistilBERt-with-the-Trainer-API"><a href="#Fine-tuning-DistilBERt-with-the-Trainer-API" class="headerlink" title="Fine-tuning DistilBERt with the Trainer API"></a>Fine-tuning DistilBERt with the Trainer API</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> transformer <span class="hljs-keyword">import</span> DataCollatorForlanguageModeling<br>data_collator = DataCollatorForLanguageModeling(tokenizer = tokenizer,mlm_probability = <span class="hljs-number">0.15</span> )<br><br>samples = [lm_dataset[<span class="hljs-string">&quot;train&quot;</span>][i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>)]<br><span class="hljs-keyword">for</span> sample <span class="hljs-keyword">in</span> samples:<br>    _ = sample.popp(<span class="hljs-string">&quot;word_ids&quot;</span>) <span class="hljs-comment">#这个会弹出key对应的value 并删除这个键对值</span><br><br><span class="hljs-keyword">import</span> collections<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> default_data_collator<br><br>ww_prolbability = <span class="hljs-number">0.2</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">whole_word_masking_data_collator</span>(<span class="hljs-params">features</span>):<br>    <span class="hljs-comment">#features是最外的字典</span><br>    <span class="hljs-comment">#feature是 键对值</span><br>    <span class="hljs-keyword">for</span> feature <span class="hljs-keyword">in</span> features:<br>        word_ids = feature.pop(<span class="hljs-string">&quot;word_ids&quot;</span>)<br>        mapping = collections.defaultdict(<span class="hljs-built_in">list</span>) <span class="hljs-comment">#mapping内部元素是一种列表</span><br>        current_word_index = -<span class="hljs-number">1</span><br>        current_word = <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">for</span> idx,word_idx <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(word_ids):<br>            <span class="hljs-keyword">if</span> word_id <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">if</span> word_id != current_word:<br>                    current_word = word_id<br>                    <span class="hljs-comment">#单词数量加1</span><br>                    current_word_index += <span class="hljs-number">1</span><br>                mapping[current_word_index].append(idx)<span class="hljs-comment">#在当前单词的位置上映射对应的token的位置</span><br>    <span class="hljs-comment"># 随机的遮蔽相关的字符</span><br>    mask = np.random.binomial(<span class="hljs-number">1</span>,wwm_probability,(<span class="hljs-built_in">len</span>(mapping))) <span class="hljs-comment">#在mapping上的每一个元素都做二项分布,概率有wwm生成,同时生成一个列表 含有1,0等元素 </span><br>    <span class="hljs-comment">#这里满足了一整个单词遮蔽的方式</span><br><br><br>    <span class="hljs-comment">#同时原来的labels和input_ids都是保留一样的值</span><br>    input_ids = feature[<span class="hljs-string">&quot;input_ids&quot;</span>] <br>    labels = feautre[<span class="hljs-string">&quot;labels&quot;</span>]<br>    new_labels = [-<span class="hljs-number">100</span>] *<span class="hljs-built_in">len</span>(labels) <span class="hljs-comment">#创建一个长度为len 每一个元素都是[ -100]的列表 , </span><br>    <span class="hljs-keyword">for</span> word_id <span class="hljs-keyword">in</span> np.where(mask)[<span class="hljs-number">0</span>]: <span class="hljs-comment">#当作布尔行代数来看</span><br>        word_id = word_id.item()<br>        <span class="hljs-keyword">for</span> idx <span class="hljs-keyword">in</span> mapping[word_id]:<br>            new_labels[idx] = labels[idx] <span class="hljs-comment">#其他的默认是-100? 这里保留着遮蔽的那些词?</span><br>            input_ids[idx] = tokenizer.mask_token_id <span class="hljs-comment">#这里应该是相当于遮蔽了?</span><br><br>    feature[<span class="hljs-string">&quot;labels&quot;</span>] = new_labels<br><br>    <span class="hljs-keyword">return</span> default_data_collator(features)<br><br>train_size =<span class="hljs-number">10_000</span><br>test_size = <span class="hljs-built_in">int</span>(<span class="hljs-number">0.1</span> * train_size) <span class="hljs-comment">#int() 表示类型转换为整数</span><br><br>downsampled_dataset = lm_datasets[<span class="hljs-string">&quot;train&quot;</span>].train_test_split(<br>    train_size = train_size, test_size=test_size, seed = <span class="hljs-number">42</span><br>)<br><br></code></pre></td></tr></table></figure><h4 id="训练数据库"><a href="#训练数据库" class="headerlink" title="训练数据库"></a>训练数据库</h4><p>给trainer定义参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> transfromers <span class="hljs-keyword">import</span> TrainingArguments<br><br>batch_size = <span class="hljs-number">64</span><br>logging_steps = <span class="hljs-built_in">len</span>(downsampled_dataset[<span class="hljs-string">&quot;train&quot;</span>]) //batch_size<br>model_name = model_checkpoint.split(<span class="hljs-string">&quot;/&quot;</span>)[-<span class="hljs-number">1</span>] <span class="hljs-comment">#按照/的形式切割,并取出最后一个值</span><br>training_args = TrainingArguments(<br>    output_dir = <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;model_name&#125;</span>-finetune-immdb&quot;</span>,<br>    overwrite_output_dir = <span class="hljs-literal">True</span>,<br>    evaluation_strategy = <span class="hljs-string">&quot;epocoh&quot;</span>,<br>    learning_rate = <span class="hljs-number">2e-5</span>,<br>    weight_decay = <span class="hljs-number">0.01</span>,<br>    per_device_train_batch_size = batch_size,<br>    per_device_eval_batch_size = batch_size,<br>    push_to_hub = <span class="hljs-literal">True</span>,<br>    fp16 = <span class="hljs-literal">True</span>,<br>    logging_steps = logging_steps,<br>)<br><br><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> Trainer<br>trainer = Trainer(<br>    model = model,<br>    args = training_args,<br>    train_dataset = downsampled_dataset[<span class="hljs-string">&quot;train&quot;</span>],<br>    eval_dataselt = downsampled_dataset[<span class="hljs-string">&quot;test&quot;</span>],<br>    data_collator = data_collator,<br>    tokenizer = tokenizer,<br>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">insert_random_mask</span>(<span class="hljs-params">batch</span>):<br>    features = [<span class="hljs-built_in">dict</span>(<span class="hljs-built_in">zip</span>(batch,t)) <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(*batch.values())] <br>    <span class="hljs-comment">#zip(*batch.value())会对一个key的东西压缩成为一个元组通常，它用于将多个列表或序列的元素按照相同索引位置配对在一起。 </span><br>    <span class="hljs-comment">#t相当于是一个元组, 用每一个key和元组中的元素进行配对</span><br>    masked_inputs = data_collator(features)<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;masked_&quot;</span>+k:v.numpy()<span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> masked_inputs.items()&#125;<br>    <span class="hljs-comment">#这个相当于在原字典之前加上“masked_&quot;的前缀</span><br><br>downsampled_dataset = downsampled_dataset.remove_columns([<span class="hljs-string">&quot;word_ids&quot;</span>])<br>eval_dataset = downsampled_dataset[<span class="hljs-string">&quot;test&quot;</span>].<span class="hljs-built_in">map</span>(<br>    insert_random_mask,<br>    batched = <span class="hljs-literal">True</span>,<br>    remove_columns = downsampled_dataset[<span class="hljs-string">&quot;test&quot;</span>].column_names,<br>)<br><br>eval_dataset = eval_dataset.rename_columns(<br>    &#123;<br>        <span class="hljs-string">&quot;masked_input_ids&quot;</span>: <span class="hljs-string">&quot;input_ids&quot;</span>,<br>        <span class="hljs-string">&quot;masked_attention_mask&quot;</span>: <span class="hljs-string">&quot;attention_mask&quot;</span>,<br>        <span class="hljs-string">&quot;masked_labels&quot;</span>: <span class="hljs-string">&quot;labels&quot;</span>,<br>    &#125;<br>)<br><br><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> DataLoader<br><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> default_data_collator<br><br>batch_size =<span class="hljs-number">64</span><br>train_dataloader = DataLoader(<br>    downsampled_dataset[<span class="hljs-string">&quot;train&quot;</span>],<br>    shuffle = <span class="hljs-literal">True</span>,<br>    batch_size = batch_size,<br>    collate_fn = data_collator<br>)<br><br>eval_dataloader = DataLoader(<br>    eval_dataset,batch_size = batch_size.collate_fn = default_data_collator<br>)<br><br>model = AutoModelForMaskedLM.from_pretrained(model_checkpoint)<br><span class="hljs-keyword">from</span> torch.optim <span class="hljs-keyword">import</span> AdamW<br>optimizer = AdamW(model.parameters(),lr= <span class="hljs-number">5e-5</span>)<br><br><span class="hljs-keyword">from</span> accelerate <span class="hljs-keyword">import</span> Accelerator<br><br>accelerator = Accelerator()<br>model,optimizer,train_dataloader,eval_dataloader = accelerator.prepare(<br>    model,optimizer,train_dataloader,eval_dataloader<br>)<br><br></code></pre></td></tr></table></figure><h3 id="Translation"><a href="#Translation" class="headerlink" title="Translation"></a>Translation</h3><h4 id="loaddata"><a href="#loaddata" class="headerlink" title="loaddata"></a>loaddata</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> datasets <span class="hljs-keyword">import</span> load_dataset<br>raw_datasets = load_dataset(<span class="hljs-string">&quot;kde4&quot;</span>, lang1=<span class="hljs-string">&quot;en&quot;</span>, lang2=<span class="hljs-string">&quot;fr&quot;</span>)<br>split_datasets = raw_datasets[<span class="hljs-string">&quot;train&quot;</span>].train_test_split(train_size=<span class="hljs-number">0.9</span>, seed=<span class="hljs-number">20</span>) <span class="hljs-comment">#选择训练集和测试集</span><br><br>split_datasets[<span class="hljs-string">&quot;validation&quot;</span>] = split_datasets.pop(<span class="hljs-string">&quot;test&quot;</span>) <span class="hljs-comment">#重命名</span><br><br>split_datasets[<span class="hljs-string">&quot;train&quot;</span>][<span class="hljs-number">1</span>][<span class="hljs-string">&quot;translation&quot;</span>] <span class="hljs-comment">#两种id 和translation-&gt;字典 同时en,fr</span><br><br><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> pipeline<br><br>model_checkpoint = <span class="hljs-string">&quot;Helsinki-NLP/opus-mt-en-fr&quot;</span><br>translator = pipeline(<span class="hljs-string">&quot;translation&quot;</span>, model=model_checkpoint)<br>translator(<span class="hljs-string">&quot;Default to expanded threads&quot;</span>)<br><br><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer<br><br>model_checkpoint = <span class="hljs-string">&quot;Helsinki-NLP/opus-mt-en-fr&quot;</span><br>tokenizer = AutoTokenizer.from_pretrained(model_checkpoint, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)<br><br><span class="hljs-comment">#tokenizer完成</span><br><br>en_sentence = split_datasets[<span class="hljs-string">&quot;train&quot;</span>][<span class="hljs-number">1</span>][<span class="hljs-string">&quot;translation&quot;</span>][<span class="hljs-string">&quot;en&quot;</span>]<br>fr_sentence = split_datasets[<span class="hljs-string">&quot;train&quot;</span>][<span class="hljs-number">1</span>][<span class="hljs-string">&quot;translation&quot;</span>][<span class="hljs-string">&quot;fr&quot;</span>]<br><br>inputs = tokenizer(en_sentence, text_target=fr_sentence)<br><br><span class="hljs-comment">#input结果生成</span><br>&#123;<span class="hljs-string">&#x27;input_ids&#x27;</span>: [<span class="hljs-number">47591</span>, <span class="hljs-number">12</span>, <span class="hljs-number">9842</span>, <span class="hljs-number">19634</span>, <span class="hljs-number">9</span>, <span class="hljs-number">0</span>], <span class="hljs-string">&#x27;attention_mask&#x27;</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>], <span class="hljs-string">&#x27;labels&#x27;</span>: [<span class="hljs-number">577</span>, <span class="hljs-number">5891</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3184</span>, <span class="hljs-number">16</span>, <span class="hljs-number">2542</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1710</span>, <span class="hljs-number">0</span>]&#125;<br><span class="hljs-comment">#没有理解错误的情况下:input_ids应该用的是对应的每一个单词在语料库的位置,labels对应的法语的位置 #同时这个注意要指定参数</span><br><span class="hljs-built_in">print</span>(tokenizer.convert_ids_to_tokens(inputs[<span class="hljs-string">&quot;labels&quot;</span>])) <span class="hljs-comment">#这里用的是把id转换成tokens的一种函数才能合理的看出是什么东西</span><br><br>max_length = <span class="hljs-number">128</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">preprocess_function</span>(<span class="hljs-params">examples</span>):<br>    inputs = [ex[<span class="hljs-string">&quot;en&quot;</span>] <span class="hljs-keyword">for</span> ex <span class="hljs-keyword">in</span> examples[<span class="hljs-string">&quot;translation&quot;</span>]]<br>    targets = [ex[<span class="hljs-string">&quot;fr&quot;</span>] <span class="hljs-keyword">for</span> ex <span class="hljs-keyword">in</span> examples[<span class="hljs-string">&quot;translation&quot;</span>]]<br>    <span class="hljs-comment">#切割</span><br>    model_inputs = tokenizer(<br>        inputs, text_target=targets, max_length=max_length, truncation=<span class="hljs-literal">True</span><br>    )<br>    <span class="hljs-keyword">return</span> model_inputs<br><br><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoModelForSeq2SeqLM<br><br>model = AutoModelForSeq2SeqLM.from_pretrained(model_checkpoint)<br><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> DataCollatorForSeq2Seq<br><br>data_collator = DataCollatorForSeq2Seq(tokenizer, model=model)<br><span class="hljs-comment">#the padding value used to pad the labels should be -100 and not the padding token of the tokenizer, to make sure those padded values are ignored in the loss computation. it takes the tokenizer used to preprocess the inputs, but it also takes the model. This is because this data collator will also be responsible for preparing the decoder input IDs, which are shifted versions of the labels with a special token at the beginning. Since this shift is done slightly differently for different architectures, the DataCollatorForSeq2Seq needs to know the model object:</span><br><br><span class="hljs-comment">#for ex</span><br>batch = data_collator([tokenized_datasets[<span class="hljs-string">&quot;train&quot;</span>][i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>)])<br>batch.keys()<br>dict_keys([<span class="hljs-string">&#x27;attention_mask&#x27;</span>, <span class="hljs-string">&#x27;input_ids&#x27;</span>, <span class="hljs-string">&#x27;labels&#x27;</span>, <span class="hljs-string">&#x27;decoder_input_ids&#x27;</span>])<br>batch[<span class="hljs-string">&quot;labels&quot;</span>]<br>batch[<span class="hljs-string">&quot;decoder_input_ids&quot;</span>]  <span class="hljs-comment"># see that they are shifted versions of the labels:</span><br><br></code></pre></td></tr></table></figure><h4 id="Metrics"><a href="#Metrics" class="headerlink" title="Metrics"></a>Metrics</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> evaluate<br>metric = evaluate.load(<span class="hljs-string">&quot;sacrebleu&quot;</span>)<br>predictions = [<br>    <span class="hljs-string">&quot;This plugin lets you translate web pages between several languages automatically.&quot;</span><br>]<br>references = [<br>    [<br>        <span class="hljs-string">&quot;This plugin allows you to automatically translate web pages between several languages.&quot;</span><br>    ]<br>]<br><span class="hljs-comment"># the predictions should be a list of sentences, but the references should be a list of lists of sentences.</span><br><br>metric.compute(predictions=predictions, references=references)<span class="hljs-comment">#调用函数评判翻译结果的好坏</span><br><br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">compute_metrics</span>(<span class="hljs-params">eval_preds</span>):<br>    preds, labels = eval_preds<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(preds,<span class="hljs-built_in">tuple</span>):<span class="hljs-comment">#检查对象类型是不是元组 //一种相关的函数</span><br>        preds = preds[<span class="hljs-number">0</span>]<br>    <br>    decoded_preds = tokenizer.batch_decode(preds,skip_special_toknes = <span class="hljs-literal">True</span>) <span class="hljs-comment">#这里应该是已经完成了替换,所以不需要在这里进行更改</span><br>    labes = np.where(labels != -<span class="hljs-number">100</span>,labels,tokenizer.pad_token_id) <span class="hljs-comment">#分别代表了检索的值,在哪检索,不符合的值替换成什么</span><br>    decoded_labels = tokenizer.batch_decode(labels,skip_special_tokens =<span class="hljs-literal">True</span>)<br><br>    decoded_preds = [pred.strip() <span class="hljs-keyword">for</span> pred <span class="hljs-keyword">in</span> decoded_preds] <span class="hljs-comment">#去除字符串两侧的空白字符（包括空格、制表符、换行符等</span><br>    decoded_labels = [[label.strip()] <span class="hljs-keyword">for</span> label <span class="hljs-keyword">in</span> decoded_labels]<br><br>    result = metric.compute(predictions=decoded_preds, references=decoded_labels) <span class="hljs-comment">#计算出结果</span><br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;bleu&quot;</span>: result[<span class="hljs-string">&quot;score&quot;</span>]&#125;<br></code></pre></td></tr></table></figure><p>评估函数</p><h4 id="Fine-tuning-the-model-1"><a href="#Fine-tuning-the-model-1" class="headerlink" title="Fine-tuning the model"></a>Fine-tuning the model</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> Seq2SeqTrainingArguments<br><br>args = Seq2SeqTrainingArguments(<br>    <span class="hljs-string">f&quot;marian-finetuned-kde4-en-to-fr&quot;</span>,<br>    evaluation_strategy=<span class="hljs-string">&quot;no&quot;</span>,<br>    save_strategy=<span class="hljs-string">&quot;epoch&quot;</span>,<br>    learning_rate=<span class="hljs-number">2e-5</span>,<br>    per_device_train_batch_size=<span class="hljs-number">32</span>,<br>    per_device_eval_batch_size=<span class="hljs-number">64</span>,<br>    weight_decay=<span class="hljs-number">0.01</span>,<br>    save_total_limit=<span class="hljs-number">3</span>,<br>    num_train_epochs=<span class="hljs-number">3</span>,<br>    predict_with_generate=<span class="hljs-literal">True</span>,<br>    fp16=<span class="hljs-literal">True</span>,<br>    push_to_hub=<span class="hljs-literal">True</span>,<br>)<br><br><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> Seq2SeqTrainingArguments<br><br>args = Seq2SeqTrainingArguments(<br>    <span class="hljs-string">f&quot;marian-finetuned-kde4-en-to-fr&quot;</span>,<br>    evaluation_strategy=<span class="hljs-string">&quot;no&quot;</span>,<br>    save_strategy=<span class="hljs-string">&quot;epoch&quot;</span>,<br>    learning_rate=<span class="hljs-number">2e-5</span>,<br>    per_device_train_batch_size=<span class="hljs-number">32</span>,<br>    per_device_eval_batch_size=<span class="hljs-number">64</span>,<br>    weight_decay=<span class="hljs-number">0.01</span>,<br>    save_total_limit=<span class="hljs-number">3</span>,<br>    num_train_epochs=<span class="hljs-number">3</span>,<br>    predict_with_generate=<span class="hljs-literal">True</span>,<br>    fp16=<span class="hljs-literal">True</span>,<span class="hljs-comment">#在GPU上加速训练</span><br>    push_to_hub=<span class="hljs-literal">True</span>,<br>)<br><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> Seq2SeqTrainer<br><br>trainer = Seq2SeqTrainer(<br>    model,<br>    args,<br>    train_dataset=tokenized_datasets[<span class="hljs-string">&quot;train&quot;</span>],<br>    eval_dataset=tokenized_datasets[<span class="hljs-string">&quot;validation&quot;</span>],<br>    data_collator=data_collator,<br>    tokenizer=tokenizer,<br>    compute_metrics=compute_metrics,<br>)<br></code></pre></td></tr></table></figure><h3 id="summation"><a href="#summation" class="headerlink" title="summation"></a>summation</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python">english_dataset.set_format(<span class="hljs-string">&quot;pandas&quot;</span>)<span class="hljs-comment">#转换数据类型</span><br>english_df = english_dataset[<span class="hljs-string">&quot;train&quot;</span>][:]<br><span class="hljs-comment"># Show counts for top 20 products</span><br>english_df[<span class="hljs-string">&quot;product_category&quot;</span>].value_counts()[:<span class="hljs-number">20</span>]<span class="hljs-comment">#统计出现次数最多的两个</span><br><br><span class="hljs-comment">#数据过滤</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">filter_books</span>(<span class="hljs-params">example</span>):<br>    <span class="hljs-keyword">return</span> (<br>        example[<span class="hljs-string">&quot;product_category&quot;</span>] == <span class="hljs-string">&quot;book&quot;</span><br>        <span class="hljs-keyword">or</span> example[<span class="hljs-string">&quot;product_category&quot;</span>] == <span class="hljs-string">&quot;digital_ebook_purchase&quot;</span><br>    )<br><br>english_dataset.reset_format() <span class="hljs-comment">#重新设置数据的格式</span><br>spanish_books = spanish_dataset.<span class="hljs-built_in">filter</span>(filter_books) <span class="hljs-comment">#应该是利用数据的格式,按照返回值来过滤数据</span><br>english_books = english_dataset.<span class="hljs-built_in">filter</span>(filter_books)<br><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> datasets <span class="hljs-keyword">import</span> concatenate_datasets, DatasetDict<br><br>books_dataset = DatasetDict()<br><br><span class="hljs-keyword">for</span> split <span class="hljs-keyword">in</span> english_books.keys():<br>    books_dataset[split] = concatenate_datasets(<br>        [english_books[split], spanish_books[split]]<br>    ) <span class="hljs-comment">#这里是取出相关的标签 然后创建一致的量.</span><br>    books_dataset[split] = books_dataset[split].shuffle(seed=<span class="hljs-number">42</span>)<br><br><span class="hljs-comment"># Peek at a few examples</span><br>show_samples(books_dataset) <span class="hljs-comment">#books混入两种不同语言的数据集</span><br><br></code></pre></td></tr></table></figure><h4 id="查看内容"><a href="#查看内容" class="headerlink" title="查看内容"></a>查看内容</h4><p>对于总结来说,过滤掉减短的总结是一件很重要的事情,否则会引起这种短总结的bias</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python">books_dataset = books_dataset.<span class="hljs-built_in">filter</span>(<span class="hljs-keyword">lambda</span> x: <span class="hljs-built_in">len</span>(x[<span class="hljs-string">&quot;review_title&quot;</span>].split()) &gt; <span class="hljs-number">2</span>)<span class="hljs-comment">#按照里面值为1的方式进行过滤</span><br><br><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer<br><br>model_checkpoint = <span class="hljs-string">&quot;google/mt5-small&quot;</span><br>tokenizer = AutoTokenizer.from_pretrained(model_checkpoint)<br><br><span class="hljs-comment">#输出结果</span><br>&#123;<span class="hljs-string">&#x27;input_ids&#x27;</span>: [<span class="hljs-number">336</span>, <span class="hljs-number">259</span>, <span class="hljs-number">28387</span>, <span class="hljs-number">11807</span>, <span class="hljs-number">287</span>, <span class="hljs-number">62893</span>, <span class="hljs-number">295</span>, <span class="hljs-number">12507</span>, <span class="hljs-number">1</span>], <span class="hljs-string">&#x27;attention_mask&#x27;</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]&#125;<br><br>tokenizer.convert_ids_to_tokens(inputs.input_ids) <span class="hljs-comment">#分词转换的语句</span><br>[<span class="hljs-string">&#x27;▁I&#x27;</span>, <span class="hljs-string">&#x27;▁&#x27;</span>, <span class="hljs-string">&#x27;loved&#x27;</span>, <span class="hljs-string">&#x27;▁reading&#x27;</span>, <span class="hljs-string">&#x27;▁the&#x27;</span>, <span class="hljs-string">&#x27;▁Hung&#x27;</span>, <span class="hljs-string">&#x27;er&#x27;</span>, <span class="hljs-string">&#x27;▁Games&#x27;</span>, <span class="hljs-string">&#x27;&lt;/s&gt;&#x27;</span>]<br><br>max_input_length = <span class="hljs-number">512</span><br>max_target_length = <span class="hljs-number">30</span><br><br><span class="hljs-comment">#这里没有看懂....</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">preprocess_function</span>(<span class="hljs-params">examples</span>):<br>    model_inputs = tokenizer(<br>        examples[<span class="hljs-string">&quot;review_body&quot;</span>],<br>        max_length=max_input_length,<br>        truncation=<span class="hljs-literal">True</span>,<br>    )<br>    labels = tokenizer(<br>        examples[<span class="hljs-string">&quot;review_title&quot;</span>], max_length=max_target_length, truncation=<span class="hljs-literal">True</span><br>    )<br>    model_inputs[<span class="hljs-string">&quot;labels&quot;</span>] = labels[<span class="hljs-string">&quot;input_ids&quot;</span>]<br>    <span class="hljs-keyword">return</span> model_inputs<br><br></code></pre></td></tr></table></figure><h4 id="create-a-strong-yet-simple-baseline"><a href="#create-a-strong-yet-simple-baseline" class="headerlink" title="create a strong, yet simple baseline!"></a>create a strong, yet simple baseline!</h4><p>A common baseline for text summarization is to simply take the first three sentences of an article, often called the lead-3 baseline.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> nltk<br><br>nltk.download(<span class="hljs-string">&quot;punkt&quot;</span>)<br><br><span class="hljs-keyword">from</span> nltk.tokenize <span class="hljs-keyword">import</span> sent_tokenize<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">three_sentence_summary</span>(<span class="hljs-params">text</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;\n&quot;</span>.join(sent_tokenize(text)[:<span class="hljs-number">3</span>])<br><br><br><span class="hljs-built_in">print</span>(three_sentence_summary(books_dataset[<span class="hljs-string">&quot;train&quot;</span>][<span class="hljs-number">1</span>][<span class="hljs-string">&quot;review_body&quot;</span>]))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">evaluate_baseline</span>(<span class="hljs-params">dataset, metric</span>):<br>    summaries = [three_sentence_summary(text) <span class="hljs-keyword">for</span> text <span class="hljs-keyword">in</span> dataset[<span class="hljs-string">&quot;review_body&quot;</span>]]<br>    <span class="hljs-keyword">return</span> metric.compute(predictions=summaries, references=dataset[<span class="hljs-string">&quot;review_title&quot;</span>])<br><br><span class="hljs-comment">#相当于用文本的前三句话作为评判的标准</span><br><br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><br>score = evaluate_baseline(books_dataset[<span class="hljs-string">&quot;validation&quot;</span>], rouge_score)<br>rouge_names = [<span class="hljs-string">&quot;rouge1&quot;</span>, <span class="hljs-string">&quot;rouge2&quot;</span>, <span class="hljs-string">&quot;rougeL&quot;</span>, <span class="hljs-string">&quot;rougeLsum&quot;</span>]<br>rouge_dict = <span class="hljs-built_in">dict</span>((rn, <span class="hljs-built_in">round</span>(score[rn].mid.fmeasure * <span class="hljs-number">100</span>, <span class="hljs-number">2</span>)) <span class="hljs-keyword">for</span> rn <span class="hljs-keyword">in</span> rouge_names)<br>rouge_dict<br></code></pre></td></tr></table></figure><h2 id="LangChain"><a href="#LangChain" class="headerlink" title="LangChain"></a>LangChain</h2><h3 id="chain"><a href="#chain" class="headerlink" title="chain"></a>chain</h3><p>起到了串联不同的agent的作用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Chain</span>(BaseModel, ABC):<br>    <span class="hljs-string">&quot;&quot;&quot;Base interface that all chains should implement.&quot;&quot;&quot;</span><br><br>    memory: BaseMemory<br>    callbacks: Callbacks<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params"></span><br><span class="hljs-params">        self,</span><br><span class="hljs-params">        inputs: <span class="hljs-type">Any</span>,</span><br><span class="hljs-params">        return_only_outputs: <span class="hljs-built_in">bool</span> = <span class="hljs-literal">False</span>,</span><br><span class="hljs-params">        callbacks: Callbacks = <span class="hljs-literal">None</span>,</span><br><span class="hljs-params">    </span>) -&gt; <span class="hljs-type">Dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-type">Any</span>]:<br>        ...<br><br><span class="hljs-comment">#use it</span><br><span class="hljs-keyword">from</span> langchain.llms <span class="hljs-keyword">import</span> OpenAI<br><span class="hljs-keyword">from</span> langchain.prompts <span class="hljs-keyword">import</span> PromptTemplate<br><br>llm = OpenAI(temperature=<span class="hljs-number">0.9</span>)<br>prompt = PromptTemplate(<span class="hljs-comment">#这里应该是创建一个prompt的模版</span><br>    input_variables=[<span class="hljs-string">&quot;product&quot;</span>],<br>    template=<span class="hljs-string">&quot;What is a good name for a company that makes &#123;product&#125;?&quot;</span>,<br>)<br><span class="hljs-keyword">from</span> langchain.chains <span class="hljs-keyword">import</span> LLMChain<br>chain = LLMChain(llm=llm, prompt=prompt)<span class="hljs-comment">#传入两个参数</span><br><br><span class="hljs-comment"># Run the chain only specifying the input variable.</span><br><span class="hljs-built_in">print</span>(chain.run(<span class="hljs-string">&quot;colorful socks&quot;</span>))<br><br><br><span class="hljs-keyword">from</span> langchain.chat_models <span class="hljs-keyword">import</span> ChatOpenAI<br><span class="hljs-keyword">from</span> langchain.prompts.chat <span class="hljs-keyword">import</span> (<br>    ChatPromptTemplate,<br>    HumanMessagePromptTemplate,<br>)<br>human_message_prompt = HumanMessagePromptTemplate(<br>        prompt=PromptTemplate(<br>            template=<span class="hljs-string">&quot;What is a good name for a company that makes &#123;product&#125;?&quot;</span>,<br>            input_variables=[<span class="hljs-string">&quot;product&quot;</span>],<br>        )<br>    )<br>chat_prompt_template = ChatPromptTemplate.from_messages([human_message_prompt])<br>chat = ChatOpenAI(temperature=<span class="hljs-number">0.9</span>)<br>chain = LLMChain(llm=chat, prompt=chat_prompt_template)<br><span class="hljs-built_in">print</span>(chain.run(<span class="hljs-string">&quot;colorful socks&quot;</span>))<br><br><span class="hljs-comment"># call chain</span><br>chat = ChatOpenAI(temperature=<span class="hljs-number">0</span>)<br>prompt_template = <span class="hljs-string">&quot;Tell me a &#123;adjective&#125; joke&quot;</span><br>llm_chain = LLMChain(llm=chat, prompt=PromptTemplate.from_template(prompt_template))<br><br>llm_chain(inputs=&#123;<span class="hljs-string">&quot;adjective&quot;</span>: <span class="hljs-string">&quot;corny&quot;</span>&#125;)<span class="hljs-comment">#生成后填入input</span><br>llm_chain(<span class="hljs-string">&quot;colorful socks&quot;</span>)<br><br><span class="hljs-comment"># 同时也可以选择apply的方式,通过填入一个列表,里面分别是这些字典</span><br><br>input_list = [<br>    &#123;<span class="hljs-string">&quot;product&quot;</span>: <span class="hljs-string">&quot;socks&quot;</span>&#125;,<br>    &#123;<span class="hljs-string">&quot;product&quot;</span>: <span class="hljs-string">&quot;computer&quot;</span>&#125;,<br>    &#123;<span class="hljs-string">&quot;product&quot;</span>: <span class="hljs-string">&quot;shoes&quot;</span>&#125;<br>]<br><br>llm_chain.apply(input_list)<br>llm_chain.generate(input_list)<span class="hljs-comment">#相似的功能,但是内容类型不同</span><br>llm_chain(<span class="hljs-string">&quot;corny&quot;</span>, return_only_outputs=<span class="hljs-literal">True</span>)<span class="hljs-comment">#取消</span><br>llm_chain.run(&#123;<span class="hljs-string">&quot;adjective&quot;</span>: <span class="hljs-string">&quot;corny&quot;</span>&#125;)<span class="hljs-comment">#等价于填入这个运行,run里面必须填入字典</span><br>llm_chain.predict(product=<span class="hljs-string">&quot;colorful socks&quot;</span>)<span class="hljs-comment">#这里必须填入关键词进行完成,如下</span><br><br>template = <span class="hljs-string">&quot;&quot;&quot;Tell me a &#123;adjective&#125; joke about &#123;subject&#125;.&quot;&quot;&quot;</span><br>prompt = PromptTemplate(template=template, input_variables=[<span class="hljs-string">&quot;adjective&quot;</span>, <span class="hljs-string">&quot;subject&quot;</span>])<br>llm_chain = LLMChain(prompt=prompt, llm=OpenAI(temperature=<span class="hljs-number">0</span>))<br><br>llm_chain.predict(adjective=<span class="hljs-string">&quot;sad&quot;</span>, subject=<span class="hljs-string">&quot;ducks&quot;</span>)<br><br><span class="hljs-comment"># 语法分析parsing the outputs</span><br><br><span class="hljs-comment">#必须带上parsing的信号</span><br><span class="hljs-keyword">from</span> langchain.output_parsers <span class="hljs-keyword">import</span> CommaSeparatedListOutputParser<br><br>output_parser = CommaSeparatedListOutputParser()<br>template = <span class="hljs-string">&quot;&quot;&quot;List all the colors in a rainbow&quot;&quot;&quot;</span><br>prompt = PromptTemplate(template=template, input_variables=[], output_parser=output_parser)<br>llm_chain = LLMChain(prompt=prompt, llm=llm)<br><br>llm_chain.predict()<br>llm_chain.predict_and_parse()<br><br><br></code></pre></td></tr></table></figure><h3 id="modules"><a href="#modules" class="headerlink" title="modules"></a>modules</h3><h4 id="prompts"><a href="#prompts" class="headerlink" title="prompts"></a>prompts</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> langchain <span class="hljs-keyword">import</span> PromptTemplate<br>prompt_template = PromptTemplate.from_template(<br>    <span class="hljs-string">&quot;Tell me a &#123;adjective&#125; joke about &#123;content&#125;.&quot;</span><br>)<span class="hljs-comment">#引号加入抽象内容 format可以放入实体</span><br>prompt_template.<span class="hljs-built_in">format</span>(adjective=<span class="hljs-string">&quot;funny&quot;</span>, content=<span class="hljs-string">&quot;chickens&quot;</span>)<br><br>invalid_prompt = PromptTemplate(<br>    input_variables=[<span class="hljs-string">&quot;adjective&quot;</span>],<span class="hljs-comment">#可以从这里买你的字典内容进行比较</span><br>    template=<span class="hljs-string">&quot;Tell me a &#123;adjective&#125; joke about &#123;content&#125;.&quot;</span><br>)<br><br><span class="hljs-comment">#chat prompt template</span><br><br><br>template = ChatPromptTemplate.from_messages([<br>    (<span class="hljs-string">&quot;system&quot;</span>, <span class="hljs-string">&quot;You are a helpful AI bot. Your name is &#123;name&#125;.&quot;</span>),<br>    (<span class="hljs-string">&quot;human&quot;</span>, <span class="hljs-string">&quot;Hello, how are you doing?&quot;</span>),<br>    (<span class="hljs-string">&quot;ai&quot;</span>, <span class="hljs-string">&quot;I&#x27;m doing well, thanks!&quot;</span>),<br>    (<span class="hljs-string">&quot;human&quot;</span>, <span class="hljs-string">&quot;&#123;user_input&#125;&quot;</span>),<span class="hljs-comment">#多轮交流?</span><br>])<br><br>messages = template.format_messages(<br>    name=<span class="hljs-string">&quot;Bob&quot;</span>,<br>    user_input=<span class="hljs-string">&quot;What is your name?&quot;</span><span class="hljs-comment">#.format_messages可以用来补充信息</span><br>)<br><br><span class="hljs-comment"># few-shot prompt templates</span><br>examples = [<br>  &#123;<br>    <span class="hljs-string">&quot;question&quot;</span>: <span class="hljs-string">&quot;Who lived longer, Muhammad Ali or Alan Turing?&quot;</span>,<br>    <span class="hljs-string">&quot;answer&quot;</span>: <br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">Are follow up questions needed here: Yes.</span><br><span class="hljs-string">Follow up: How old was Muhammad Ali when he died?</span><br><span class="hljs-string">Intermediate answer: Muhammad Ali was 74 years old when he died.</span><br><span class="hljs-string">Follow up: How old was Alan Turing when he died?</span><br><span class="hljs-string">Intermediate answer: Alan Turing was 41 years old when he died.</span><br><span class="hljs-string">So the final answer is: Muhammad Ali</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>  &#125;] <span class="hljs-comment">#examples表现形式为列表中嵌入相关的字典</span><br>example_prompt = PromptTemplate(input_variables=[<span class="hljs-string">&quot;question&quot;</span>, <span class="hljs-string">&quot;answer&quot;</span>], template=<span class="hljs-string">&quot;Question: &#123;question&#125;\n&#123;answer&#125;&quot;</span>)<br><br><span class="hljs-built_in">print</span>(example_prompt.<span class="hljs-built_in">format</span>(**examples[<span class="hljs-number">0</span>]))<span class="hljs-comment">## **在python中传递了字典中的健对值</span><br><br>prompt = FewShotPromptTemplate(<br>    examples=examples, <br>    example_prompt=example_prompt, <br>    suffix=<span class="hljs-string">&quot;Question: &#123;input&#125;&quot;</span>, <span class="hljs-comment">#添加一个后缀</span><br>    input_variables=[<span class="hljs-string">&quot;input&quot;</span>],<span class="hljs-comment">#加入一个input作为一个输出变量,放在后面用来填入</span><br>)<br><br><span class="hljs-built_in">print</span>(prompt.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">input</span>=<span class="hljs-string">&quot;Who was the father of Mary Ball Washington?&quot;</span>))<span class="hljs-comment">#同时format是直接把这个字符串用来返回</span><br><br><span class="hljs-comment"># 通过exampleselector完成相关的操作</span><br><span class="hljs-keyword">from</span> langchain.prompts.example_selector <span class="hljs-keyword">import</span> SemanticSimilarityExampleSelector<br><span class="hljs-keyword">from</span> langchain.vectorstores <span class="hljs-keyword">import</span> Chroma<br><span class="hljs-keyword">from</span> langchain.embeddings <span class="hljs-keyword">import</span> OpenAIEmbeddings<br>example_selector = SemanticSimilarityExampleSelector.from_examples(<br>    <span class="hljs-comment"># This is the list of examples available to select from.</span><br>    examples,<br>    <span class="hljs-comment"># This is the embedding class used to produce embeddings which are used to measure semantic similarity.</span><br>    OpenAIEmbeddings(),<br>    <span class="hljs-comment"># This is the VectorStore class that is used to store the embeddings and do a similarity search over.</span><br>    Chroma,<br>    <span class="hljs-comment"># This is the number of examples to produce.</span><br>    k=<span class="hljs-number">1</span><br>)<br><br><span class="hljs-comment"># Few-shot examples for chat models - API</span><br>langchain.prompts.few_shot.FewShotChatMessagePromptTemplate 类<br>examples = [<br>    &#123;<span class="hljs-string">&quot;input&quot;</span>: <span class="hljs-string">&quot;2+2&quot;</span>, <span class="hljs-string">&quot;output&quot;</span>: <span class="hljs-string">&quot;4&quot;</span>&#125;,<br>    &#123;<span class="hljs-string">&quot;input&quot;</span>: <span class="hljs-string">&quot;2+3&quot;</span>, <span class="hljs-string">&quot;output&quot;</span>: <span class="hljs-string">&quot;5&quot;</span>&#125;,<span class="hljs-comment">#相当于两个</span><br>]<br>example_prompt = ChatPromptTemplate.from_messages(<br>    [(<span class="hljs-string">&#x27;human&#x27;</span>, <span class="hljs-string">&#x27;&#123;input&#125;&#x27;</span>), (<span class="hljs-string">&#x27;ai&#x27;</span>, <span class="hljs-string">&#x27;&#123;output&#125;&#x27;</span>)]<br>)<br>few_shot_prompt = FewShotChatMessagePromptTemplate(<br>    examples=examples,<br>    <span class="hljs-comment"># This is a prompt template used to format each individual example.</span><br>    example_prompt=example_prompt,<br>)<br>final_prompt = ChatPromptTemplate.from_messages(<br>    [<br>        (<span class="hljs-string">&#x27;system&#x27;</span>, <span class="hljs-string">&#x27;You are a helpful AI Assistant&#x27;</span>),<br>        few_shot_prompt,<br>        (<span class="hljs-string">&#x27;human&#x27;</span>, <span class="hljs-string">&#x27;&#123;input&#125;&#x27;</span>),<br>    ]<br>)<br><br><span class="hljs-comment">#root chain</span><br><br><br></code></pre></td></tr></table></figure><h3 id="memory"><a href="#memory" class="headerlink" title="memory"></a>memory</h3><h4 id="store"><a href="#store" class="headerlink" title="store"></a>store</h4><p>呃呃,感觉这个单元有点像存在第三方库里面?</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#通过chatmessagehistorty类来完成相关操作</span><br><span class="hljs-keyword">from</span> langchain.memory <span class="hljs-keyword">import</span> ChatMessageHistory<br>history = ChatMessageHistory()<br>history.add_user_message(<span class="hljs-string">&quot;HI&quot;</span>)<br>history.add_ai_message(<span class="hljs-string">&quot;what&#x27;s up?&quot;</span>)<br>history.messages<br>    [HumanMessage(content=<span class="hljs-string">&#x27;hi!&#x27;</span>, additional_kwargs=&#123;&#125;),<br>     AIMessage(content=<span class="hljs-string">&#x27;whats up?&#x27;</span>, additional_kwargs=&#123;&#125;)]<br><br><span class="hljs-comment">#for start</span><br><span class="hljs-keyword">from</span> langchain.memory <span class="hljs-keyword">import</span> ConversationBufferjMemory<br>memory = ConversationBufferMemory()<br>memory = ConversationBufferMemory(memory_key=<span class="hljs-string">&quot;chat_history&quot;</span>)<span class="hljs-comment">#把history的键值更改</span><br>memory.chat_memory.add_user_message(<span class="hljs-string">&quot;hi!&quot;</span>)<br>memory.chat_memory.add_ai_message(<span class="hljs-string">&quot;what&#x27;s up?&quot;</span>)<br>memory.load_memory_variables(&#123;&#125;)<span class="hljs-comment">#同时可以发现里面放入的是字典同时含有history以及AI: 可以使用</span><br><br>memory = ConversationBufferMemory(return_messages=<span class="hljs-literal">True</span>)<br>memory.chat_memory.add_user_message(<span class="hljs-string">&quot;hi!&quot;</span>)<br>memory.chat_memory.add_ai_message(<span class="hljs-string">&quot;what&#x27;s up?&quot;</span>)<br><span class="hljs-comment">#return list of memory</span><br><span class="hljs-comment">#可以通过input_key以及output_key实现参数相关的方案</span><br><br><span class="hljs-comment"># end to end</span><br><span class="hljs-keyword">from</span> langchain.llms <span class="hljs-keyword">import</span> OpenAI<br><span class="hljs-keyword">from</span> langchain.prompts <span class="hljs-keyword">import</span> PromptTemplate<br><span class="hljs-keyword">from</span> langchain.chains <span class="hljs-keyword">import</span> LLMChain<br><span class="hljs-keyword">from</span> langchain.memory <span class="hljs-keyword">import</span> ConversationBufferMemory<br><br><br>llm = OpenAI(temperature=<span class="hljs-number">0</span>)<br><span class="hljs-comment"># Notice that &quot;chat_history&quot; is present in the prompt template</span><br>template = <span class="hljs-string">&quot;&quot;&quot;You are a nice chatbot having a conversation with a human.</span><br><span class="hljs-string"></span><br><span class="hljs-string">Previous conversation:</span><br><span class="hljs-string">&#123;chat_history&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">New human question: &#123;question&#125;</span><br><span class="hljs-string">Response:&quot;&quot;&quot;</span><br>prompt = PromptTemplate.from_template(template)<br><span class="hljs-comment"># Notice that we need to align the `memory_key`</span><br>memory = ConversationBufferMemory(memory_key=<span class="hljs-string">&quot;chat_history&quot;</span>)<br>conversation = LLMChain(<br>    llm=llm,<br>    prompt=prompt,<br>    verbose=<span class="hljs-literal">True</span>,<br>    memory=memory<br>)<br><span class="hljs-comment"># Notice that we just pass in the `question` variables - `chat_history` gets populated by memory</span><br>conversation(&#123;<span class="hljs-string">&quot;question&quot;</span>: <span class="hljs-string">&quot;hi&quot;</span>&#125;)<br><br><span class="hljs-comment"># Memory in LLMChain</span><br><span class="hljs-keyword">from</span> langchain.chains <span class="hljs-keyword">import</span> LLMChain<br><span class="hljs-keyword">from</span> langchain.llms <span class="hljs-keyword">import</span> OpenAI<br><span class="hljs-keyword">from</span> langchain.memory <span class="hljs-keyword">import</span> ConversationBufferMemory<br><span class="hljs-keyword">from</span> langchain.prompts <span class="hljs-keyword">import</span> PromptTemplate<br><br>template = <span class="hljs-string">&quot;&quot;&quot;You are a chatbot having a conversation with a human.</span><br><span class="hljs-string"></span><br><span class="hljs-string">&#123;chat_history&#125;</span><br><span class="hljs-string">Human: &#123;human_input&#125;</span><br><span class="hljs-string">Chatbot:&quot;&quot;&quot;</span><br><br>prompt = PromptTemplate(<br>    input_variables=[<span class="hljs-string">&quot;chat_history&quot;</span>, <span class="hljs-string">&quot;human_input&quot;</span>], template=template<br>)<br><span class="hljs-comment">#这个应该代表的是可以在里面输入变量,同时通过指明input_variables为外部变量,可以在之后添加进去</span><br>memory = ConversationBufferMemory(memory_key=<span class="hljs-string">&quot;chat_history&quot;</span>)<br>llm = OpenAI()<br>llm_chain = LLMChain(<br>    llm=llm,<br>    prompt=prompt,<br>    verbose=<span class="hljs-literal">True</span>,<br>    memory=memory,<br>)<br><span class="hljs-comment">#langchain提供了memort接口,应该可以自动链接prompt里的数据以及memory里的数据且标签为chat_history</span><br>llm_chain.predict(human_input=<span class="hljs-string">&quot;Hi there my friend&quot;</span>) <span class="hljs-comment"># 这里通过字符串的方式进行预测</span><br><br><br><span class="hljs-comment"># 增加记忆LLM</span><br><span class="hljs-keyword">from</span> langchain.chat_models <span class="hljs-keyword">import</span> ChatOpenAI<br><span class="hljs-keyword">from</span> langchain.schema <span class="hljs-keyword">import</span> SystemMessage<br><span class="hljs-keyword">from</span> langchain.prompts <span class="hljs-keyword">import</span> ChatPromptTemplate, HumanMessagePromptTemplate, MessagesPlaceholder<br><br>prompt = ChatPromptTemplate.from_messages([<span class="hljs-comment"># 组合数据的形式</span><br>    SystemMessage(content=<span class="hljs-string">&quot;You are a chatbot having a conversation with a human.&quot;</span>), <span class="hljs-comment"># The persistent system prompt</span><br>    MessagesPlaceholder(variable_name=<span class="hljs-string">&quot;chat_history&quot;</span>), <span class="hljs-comment"># Where the memory will be stored.记忆存储的key</span><br>    HumanMessagePromptTemplate.from_template(<span class="hljs-string">&quot;&#123;human_input&#125;&quot;</span>), <span class="hljs-comment"># Where the human input will injected</span><br>])<br>    <br>memory = ConversationBufferMemory(memory_key=<span class="hljs-string">&quot;chat_history&quot;</span>, return_messages=<span class="hljs-literal">True</span>)<br><br><br><span class="hljs-comment"># Memory in the Multi-Input Chain</span><br><span class="hljs-keyword">from</span> langchain.embeddings.openai <span class="hljs-keyword">import</span> OpenAIEmbeddings<br><span class="hljs-keyword">from</span> langchain.embeddings.cohere <span class="hljs-keyword">import</span> CohereEmbeddings<br><span class="hljs-keyword">from</span> langchain.text_splitter <span class="hljs-keyword">import</span> CharacterTextSplitter<br><span class="hljs-keyword">from</span> langchain.vectorstores.elastic_vector_search <span class="hljs-keyword">import</span> ElasticVectorSearch<br><span class="hljs-keyword">from</span> langchain.vectorstores <span class="hljs-keyword">import</span> Chroma<br><span class="hljs-keyword">from</span> langchain.docstore.document <span class="hljs-keyword">import</span> Document<br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;../../state_of_the_union.txt&quot;</span>) <span class="hljs-keyword">as</span> f:<br>    state_of_the_union = f.read()<br>text_splitter = CharacterTextSplitter(chunk_size=<span class="hljs-number">1000</span>, chunk_overlap=<span class="hljs-number">0</span>)<br>texts = text_splitter.split_text(state_of_the_union)<br><br>embeddings = OpenAIEmbeddings()<br>docsearch = Chroma.from_texts(<br>    texts, embeddings, metadatas=[&#123;<span class="hljs-string">&quot;source&quot;</span>: i&#125; <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(texts))]<br>)<span class="hljs-comment"># 按照source texts每一个单元都作为嵌入数据处理</span><br>query = <span class="hljs-string">&quot;What did the president say about Justice Breyer&quot;</span><br>docs = docsearch.similarity_search(query) <span class="hljs-comment"># 数据库可以直接使用其处理 .similarity_search()检索</span><br><br><span class="hljs-keyword">from</span> langchain.chains.question_answering <span class="hljs-keyword">import</span> load_qa_chain<br><span class="hljs-keyword">from</span> langchain.llms <span class="hljs-keyword">import</span> OpenAI<br><span class="hljs-keyword">from</span> langchain.prompts <span class="hljs-keyword">import</span> PromptTemplate<br><span class="hljs-keyword">from</span> langchain.memory <span class="hljs-keyword">import</span> ConversationBufferMemory<br><br>template = <span class="hljs-string">&quot;&quot;&quot;You are a chatbot having a conversation with a human.</span><br><span class="hljs-string"></span><br><span class="hljs-string">Given the following extracted parts of a long document and a question, create a final answer.</span><br><span class="hljs-string"></span><br><span class="hljs-string">&#123;context&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">&#123;chat_history&#125;</span><br><span class="hljs-string">Human: &#123;human_input&#125;</span><br><span class="hljs-string">Chatbot:&quot;&quot;&quot;</span><br><br>prompt = PromptTemplate(<br>    input_variables=[<span class="hljs-string">&quot;chat_history&quot;</span>, <span class="hljs-string">&quot;human_input&quot;</span>, <span class="hljs-string">&quot;context&quot;</span>], template=template<br>)<br>memory = ConversationBufferMemory(memory_key=<span class="hljs-string">&quot;chat_history&quot;</span>, input_key=<span class="hljs-string">&quot;human_input&quot;</span>)<span class="hljs-comment">#</span><br>chain = load_qa_chain(<br>    OpenAI(temperature=<span class="hljs-number">0</span>), chain_type=<span class="hljs-string">&quot;stuff&quot;</span>, memory=memory, prompt=prompt<br>)<br><span class="hljs-comment"># memory in agent</span><br><br>search = GoogleSearchAPIWrapper()<br>tools = [<br>    Tool(<span class="hljs-comment">#? </span><br>        name=<span class="hljs-string">&quot;Search&quot;</span>,<span class="hljs-comment">#ming ming</span><br>        func=search.run,<span class="hljs-comment">#函数功能</span><br>        description=<span class="hljs-string">&quot;useful for when you need to answer questions about current events&quot;</span>,<br>    )<br>]<span class="hljs-comment">#可以使用的功能</span><br><br><br>prefix = <span class="hljs-string">&quot;&quot;&quot;Have a conversation with a human, answering the following questions as best you can. You have access to the following tools:&quot;&quot;&quot;</span><br>suffix = <span class="hljs-string">&quot;&quot;&quot;Begin!&quot;</span><br><span class="hljs-string"></span><br><span class="hljs-string">&#123;chat_history&#125;</span><br><span class="hljs-string">Question: &#123;input&#125;</span><br><span class="hljs-string">&#123;agent_scratchpad&#125;&quot;&quot;&quot;</span><br><span class="hljs-comment"># </span><br>prompt = ZeroShotAgent.create_prompt(<br>    tools,<br>    prefix=prefix,<br>    suffix=suffix,<br>    input_variables=[<span class="hljs-string">&quot;input&quot;</span>, <span class="hljs-string">&quot;chat_history&quot;</span>, <span class="hljs-string">&quot;agent_scratchpad&quot;</span>],<br>)<span class="hljs-comment"># ? 可以直接嵌入前缀以及后缀吗</span><br><br>memory = ConversationBufferMemory(memory_key=<span class="hljs-string">&quot;chat_history&quot;</span>)<span class="hljs-comment">#按照之前的</span><br><br>llm_chain = LLMChain(llm=OpenAI(temperature=<span class="hljs-number">0</span>), prompt=prompt)<br>agent = ZeroShotAgent(llm_chain=llm_chain, tools=tools, verbose=<span class="hljs-literal">True</span>)<span class="hljs-comment">#代理人, 工具</span><br>agent_chain = AgentExecutor.from_agent_and_tools(<br>    agent=agent, tools=tools, verbose=<span class="hljs-literal">True</span>, memory=memory<br>)<span class="hljs-comment">#memory 重新嵌入agent_chain </span><br><br><br><br><br></code></pre></td></tr></table></figure><h3 id="retrieve-检索器"><a href="#retrieve-检索器" class="headerlink" title="retrieve 检索器"></a>retrieve 检索器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-comment"># quick start!</span><br><br><br><span class="hljs-comment">#document loader - ex for csv-&gt;以逗号作为分隔的文件</span><br><span class="hljs-keyword">from</span> langchain.document_loaders.csv_loader <span class="hljs-keyword">import</span> CSVLoader<br>loader = CSVLoader(file_path = <span class="hljs-string">&#x27;./example_data/mllb_teams_2012.csv&#x27;</span>)<br>data = loader.load()<br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;../../state_of_the_union.txt&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    state_of_the_union = f.read()<br><span class="hljs-keyword">from</span> langchain.text_splitter <span class="hljs-keyword">import</span> RecursiveCharacterTextSplitter<br>text_splitter = RecursiveCharacterTextSplitter(<br>    <span class="hljs-comment"># Set a really small chunk size, just to show.</span><br>    chunk_size = <span class="hljs-number">100</span>,<span class="hljs-comment">#最长数量</span><br>    chunk_overlap  = <span class="hljs-number">20</span>,<span class="hljs-comment">#重叠数量</span><br>    length_function = <span class="hljs-built_in">len</span>,<br>    add_start_index = <span class="hljs-literal">True</span>,<span class="hljs-comment">#切割后的开始字符在原来的数组中的位置</span><br>)<br><br><span class="hljs-comment">#---以上略去了一些其他的切割方式</span><br><br><span class="hljs-comment">#Lost in the middle: The problem with long contexts:When models must access relevant information in the middle of long contexts, they tend to ignore the provided documents</span><br><span class="hljs-comment">#采用重新打乱的方式完成(检索之后)</span><br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> chromadb<br><span class="hljs-keyword">from</span> langchain.vectorstores <span class="hljs-keyword">import</span> Chroma<br><span class="hljs-keyword">from</span> langchain.embeddings <span class="hljs-keyword">import</span> HuggingFaceEmbeddings<br><span class="hljs-keyword">from</span> langchain.document_transformers <span class="hljs-keyword">import</span> (<br>    LongContextReorder,<br>)<br><span class="hljs-keyword">from</span> langchain.chains <span class="hljs-keyword">import</span> StuffDocumentsChain, LLMChain<br><span class="hljs-keyword">from</span> langchain.prompts <span class="hljs-keyword">import</span> PromptTemplate<br><span class="hljs-keyword">from</span> langchain.llms <span class="hljs-keyword">import</span> OpenAI<br><br><span class="hljs-comment"># Get embeddings.</span><br>embeddings = HuggingFaceEmbeddings(model_name=<span class="hljs-string">&quot;all-MiniLM-L6-v2&quot;</span>)<br><br>texts = [<br>    <span class="hljs-string">&quot;Basquetball is a great sport.&quot;</span>,<br>    <span class="hljs-string">&quot;Fly me to the moon is one of my favourite songs.&quot;</span>,<br>    <span class="hljs-string">&quot;The Celtics are my favourite team.&quot;</span>,<br>    <span class="hljs-string">&quot;This is a document about the Boston Celtics&quot;</span>,<br>    <span class="hljs-string">&quot;I simply love going to the movies&quot;</span>,<br>    <span class="hljs-string">&quot;The Boston Celtics won the game by 20 points&quot;</span>,<br>    <span class="hljs-string">&quot;This is just a random text.&quot;</span>,<br>    <span class="hljs-string">&quot;Elden Ring is one of the best games in the last 15 years.&quot;</span>,<br>    <span class="hljs-string">&quot;L. Kornet is one of the best Celtics players.&quot;</span>,<br>    <span class="hljs-string">&quot;Larry Bird was an iconic NBA player.&quot;</span>,<br>]<br><br><span class="hljs-comment"># Create a retriever</span><br>retriever = Chroma.from_texts(texts, embedding=embeddings).as_retriever(<br>    search_kwargs=&#123;<span class="hljs-string">&quot;k&quot;</span>: <span class="hljs-number">10</span>&#125;<br>)<br>query = <span class="hljs-string">&quot;What can you tell me about the Celtics?&quot;</span><br><br><span class="hljs-comment"># Get relevant documents ordered by relevance score</span><br>docs = retriever.get_relevant_documents(query)<br>docs<br><span class="hljs-comment">#这个b东西穿模了吧</span><br><br><span class="hljs-comment">#embedding</span><br><span class="hljs-keyword">from</span> langchain.embeddings <span class="hljs-keyword">import</span> OpenAIEmbeddings<br><br>embeddings_model = OpenAIEmbeddings()<span class="hljs-comment">#直接设置</span><br>embeddings = embeddings_model.embed_documents(<br>    [<br>        <span class="hljs-string">&quot;Hi there!&quot;</span>,<br>        <span class="hljs-string">&quot;Oh, hello!&quot;</span>,<br>        <span class="hljs-string">&quot;What&#x27;s your name?&quot;</span>,<br>        <span class="hljs-string">&quot;My friends call me World&quot;</span>,<br>        <span class="hljs-string">&quot;Hello World!&quot;</span><br>    ]<br>)<span class="hljs-comment">#分解的时候支持列表里的多个字符串的形式</span><br><span class="hljs-built_in">len</span>(embeddings), <span class="hljs-built_in">len</span>(embeddings[<span class="hljs-number">0</span>])<span class="hljs-comment">#表示有多少行的变量长度</span><br><br>embedded_query = embeddings_model.embed_query(<span class="hljs-string">&quot;What was the name mentioned in the conversation?&quot;</span>)<br>embedded_query[:<span class="hljs-number">5</span>]<span class="hljs-comment">#询问以及其他的含有不同的表征形式</span><br><br><span class="hljs-comment">#支持caching技术</span><br><span class="hljs-comment">#TODO</span><br><span class="hljs-comment">#Vector stores </span><br><span class="hljs-comment">#存储embedding向量同时之后用于查询的方式</span><br><span class="hljs-keyword">from</span> langchain.document_loaders <span class="hljs-keyword">import</span> TextLoader<br><span class="hljs-keyword">from</span> langchain.embeddings.openai <span class="hljs-keyword">import</span> OpenAIEmbeddings<br><span class="hljs-keyword">from</span> langchain.text_splitter <span class="hljs-keyword">import</span> CharacterTextSplitter<br><span class="hljs-keyword">from</span> langchain.vectorstores <span class="hljs-keyword">import</span> FAISS<br><br><span class="hljs-comment"># Load the document, split it into chunks, embed each chunk and load it into the vector store.</span><br>raw_documents = TextLoader(<span class="hljs-string">&#x27;../../../state_of_the_union.txt&#x27;</span>).load()<br>text_splitter = CharacterTextSplitter(chunk_size=<span class="hljs-number">1000</span>, chunk_overlap=<span class="hljs-number">0</span>)<br>documents = text_splitter.split_documents(raw_documents)<span class="hljs-comment">#已经完成相关的切割了</span><br>db = FAISS.from_documents(documents, OpenAIEmbeddings())<br><span class="hljs-comment">#相似性的查询</span><br>query = <span class="hljs-string">&quot;What did the president say about Ketanji Brown Jackson&quot;</span><br>docs = db.similarity_search(query)<br><span class="hljs-built_in">print</span>(docs[<span class="hljs-number">0</span>].page_content)<br><span class="hljs-comment">#vector查询</span><br>embedding_vector = OpenAIEmbeddings().embed_query(query)<br>docs = db.similarity_search_by_vector(embedding_vector)<br><span class="hljs-built_in">print</span>(docs[<span class="hljs-number">0</span>].page_content)<br><span class="hljs-comment">#结果一致</span><br><br><span class="hljs-comment">#retrieve QUICK START</span><br><span class="hljs-keyword">from</span> abc <span class="hljs-keyword">import</span> ABC, abstractmethod<br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">Any</span>, <span class="hljs-type">List</span><br><span class="hljs-keyword">from</span> langchain.schema <span class="hljs-keyword">import</span> Document<br><span class="hljs-keyword">from</span> langchain.callbacks.manager <span class="hljs-keyword">import</span> Callbacks<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseRetriever</span>(<span class="hljs-title class_ inherited__">ABC</span>):<br>    ...<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_relevant_documents</span>(<span class="hljs-params"></span><br><span class="hljs-params">        self, query: <span class="hljs-built_in">str</span>, *, callbacks: Callbacks = <span class="hljs-literal">None</span>, **kwargs: <span class="hljs-type">Any</span></span><br><span class="hljs-params">    </span>) -&gt; <span class="hljs-type">List</span>[Document]:<br>        <span class="hljs-string">&quot;&quot;&quot;Retrieve documents relevant to a query.</span><br><span class="hljs-string">        Args:</span><br><span class="hljs-string">            query: string to find relevant documents for</span><br><span class="hljs-string">            callbacks: Callback manager or list of callbacks</span><br><span class="hljs-string">        Returns:</span><br><span class="hljs-string">            List of relevant documents</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        ...<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">aget_relevant_documents</span>(<span class="hljs-params"></span><br><span class="hljs-params">        self, query: <span class="hljs-built_in">str</span>, *, callbacks: Callbacks = <span class="hljs-literal">None</span>, **kwargs: <span class="hljs-type">Any</span></span><br><span class="hljs-params">    </span>) -&gt; <span class="hljs-type">List</span>[Document]:<br>        <span class="hljs-string">&quot;&quot;&quot;Asynchronously get documents relevant to a query.</span><br><span class="hljs-string">        Args:</span><br><span class="hljs-string">            query: string to find relevant documents for</span><br><span class="hljs-string">            callbacks: Callback manager or list of callbacks</span><br><span class="hljs-string">        Returns:</span><br><span class="hljs-string">            List of relevant documents</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        ...<br><br><span class="hljs-keyword">from</span> langchain.chains <span class="hljs-keyword">import</span> RetrievalQA<br><span class="hljs-keyword">from</span> langchain.llms <span class="hljs-keyword">import</span> OpenAI<br><span class="hljs-keyword">from</span> langchain.document_loaders <span class="hljs-keyword">import</span> TextLoader<br>loader = TextLoader(<span class="hljs-string">&#x27;../state_of_the_union.txt&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf8&#x27;</span>)<br><span class="hljs-keyword">from</span> langchain.indexes <span class="hljs-keyword">import</span> VectorstoreIndexCreator<br>index = VectorstoreIndexCreator().from_loaders([loader])<span class="hljs-comment">#</span><br>query = <span class="hljs-string">&quot;What did the president say about Ketanji Brown Jackson&quot;</span><br>index.query_with_sources(query)<span class="hljs-comment">#返回相关的字符串</span><br>query = <span class="hljs-string">&quot;What did the president say about Ketanji Brown Jackson&quot;</span><br>index.query_with_sources(query)<span class="hljs-comment">#字典 含有详细的相关的文本</span><br>index.query(<span class="hljs-string">&quot;Summarize the general content of this document.&quot;</span>, retriever_kwargs=&#123;<span class="hljs-string">&quot;search_kwargs&quot;</span>: &#123;<span class="hljs-string">&quot;filter&quot;</span>: &#123;<span class="hljs-string">&quot;source&quot;</span>: <span class="hljs-string">&quot;../state_of_the_union.txt&quot;</span>&#125;&#125;&#125;)<span class="hljs-comment">#同时可以选择过滤的方式</span><br><br><br><span class="hljs-comment">#muliquery use</span><br><br><br><span class="hljs-comment"># Build a sample vectorDB</span><br><span class="hljs-keyword">from</span> langchain.vectorstores <span class="hljs-keyword">import</span> Chroma<br><span class="hljs-keyword">from</span> langchain.document_loaders <span class="hljs-keyword">import</span> WebBaseLoader<br><span class="hljs-keyword">from</span> langchain.embeddings.openai <span class="hljs-keyword">import</span> OpenAIEmbeddings<br><span class="hljs-keyword">from</span> langchain.text_splitter <span class="hljs-keyword">import</span> RecursiveCharacterTextSplitter<br><br><span class="hljs-comment"># Load blog post</span><br>loader = WebBaseLoader(<span class="hljs-string">&quot;https://lilianweng.github.io/posts/2023-06-23-agent/&quot;</span>)<br>data = loader.load()<br><br><span class="hljs-comment"># Split</span><br>text_splitter = RecursiveCharacterTextSplitter(chunk_size=<span class="hljs-number">500</span>, chunk_overlap=<span class="hljs-number">0</span>)<br>splits = text_splitter.split_documents(data)<br><br><span class="hljs-comment"># VectorDB</span><br>embedding = OpenAIEmbeddings()<br>vectordb = Chroma.from_documents(documents=splits, embedding=embedding)<br><span class="hljs-comment">#chroma表示split用embedding处理后存入数据库</span><br><span class="hljs-keyword">from</span> langchain.chat_models <span class="hljs-keyword">import</span> ChatOpenAI<br><span class="hljs-keyword">from</span> langchain.retrievers.multi_query <span class="hljs-keyword">import</span> MultiQueryRetriever<br><br>question = <span class="hljs-string">&quot;What are the approaches to Task Decomposition?&quot;</span><br>llm = ChatOpenAI(temperature=<span class="hljs-number">0</span>)<br>retriever_from_llm = MultiQueryRetriever.from_llm(<br>    retriever=vectordb.as_retriever(), llm=llm<br>)<br>unique_docs = retriever_from_llm.get_relevant_documents(query=question)<span class="hljs-comment">#表示依据询问,连续产生相关的疑问来进行检索</span><br><span class="hljs-built_in">len</span>(unique_docs)<br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">List</span><br><span class="hljs-keyword">from</span> langchain <span class="hljs-keyword">import</span> LLMChain<br><span class="hljs-keyword">from</span> pydantic <span class="hljs-keyword">import</span> BaseModel, Field<span class="hljs-comment">#数据验证库 可以定义不同名字的类</span><br><span class="hljs-keyword">from</span> langchain.prompts <span class="hljs-keyword">import</span> PromptTemplate<br><span class="hljs-keyword">from</span> langchain.output_parsers <span class="hljs-keyword">import</span> PydanticOutputParser<br><br><br><span class="hljs-comment"># Output parser will split the LLM result into a list of queries</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LineList</span>(<span class="hljs-title class_ inherited__">BaseModel</span>):<br>    <span class="hljs-comment"># &quot;lines&quot; is the key (attribute name) of the parsed output</span><br>    lines: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>] = Field(description=<span class="hljs-string">&quot;Lines of text&quot;</span>)<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LineListOutputParser</span>(<span class="hljs-title class_ inherited__">PydanticOutputParser</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-built_in">super</span>().__init__(pydantic_object=LineList)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">parse</span>(<span class="hljs-params">self, text: <span class="hljs-built_in">str</span></span>) -&gt; LineList:<br>        lines = text.strip().split(<span class="hljs-string">&quot;\n&quot;</span>)<br>        <span class="hljs-keyword">return</span> LineList(lines=lines)<br><br><br>output_parser = LineListOutputParser()<br><br>QUERY_PROMPT = PromptTemplate(<br>    input_variables=[<span class="hljs-string">&quot;question&quot;</span>],<br>    template=<span class="hljs-string">&quot;&quot;&quot;You are an AI language model assistant. Your task is to generate five </span><br><span class="hljs-string">    different versions of the given user question to retrieve relevant documents from a vector </span><br><span class="hljs-string">    database. By generating multiple perspectives on the user question, your goal is to help</span><br><span class="hljs-string">    the user overcome some of the limitations of the distance-based similarity search. </span><br><span class="hljs-string">    Provide these alternative questions seperated by newlines.</span><br><span class="hljs-string">    Original question: &#123;question&#125;&quot;&quot;&quot;</span>,<br>)<br>llm = ChatOpenAI(temperature=<span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># Chain</span><br>llm_chain = LLMChain(llm=llm, prompt=QUERY_PROMPT, output_parser=output_parser)<br><br><span class="hljs-comment"># Other inputs</span><br>question = <span class="hljs-string">&quot;What are the approaches to Task Decomposition?&quot;</span><br><br><span class="hljs-comment"># 按时间检索完成</span><br>scoring = semantic_similarity + (<span class="hljs-number">1.0</span> - decay_rate) ^ hours_passed<br><span class="hljs-comment">#每一次access都需要更新自己的记忆</span><br><span class="hljs-keyword">import</span> faiss<br><br><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime, timedelta<br><span class="hljs-keyword">from</span> langchain.docstore <span class="hljs-keyword">import</span> InMemoryDocstore<br><span class="hljs-keyword">from</span> langchain.embeddings <span class="hljs-keyword">import</span> OpenAIEmbeddings<br><span class="hljs-keyword">from</span> langchain.retrievers <span class="hljs-keyword">import</span> TimeWeightedVectorStoreRetriever<br><span class="hljs-keyword">from</span> langchain.schema <span class="hljs-keyword">import</span> Document<br><span class="hljs-keyword">from</span> langchain.vectorstores <span class="hljs-keyword">import</span> FAISS<br><br><span class="hljs-comment"># Define your embedding model</span><br>embeddings_model = OpenAIEmbeddings()<br><span class="hljs-comment"># Initialize the vectorstore as empty</span><br>embedding_size = <span class="hljs-number">1536</span><br>index = faiss.IndexFlatL2(embedding_size)<br>vectorstore = FAISS(embeddings_model.embed_query, index, InMemoryDocstore(&#123;&#125;), &#123;&#125;)<span class="hljs-comment">#vectorstore 用于描述存入的方式</span><br>retriever = TimeWeightedVectorStoreRetriever(vectorstore=vectorstore, decay_rate=<span class="hljs-number">.0000000000000000000000001</span>, k=<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>NLP_hug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++_learn</title>
    <link href="/2023/07/26/c-learn/"/>
    <url>/2023/07/26/c-learn/</url>
    
    <content type="html"><![CDATA[<h1 id="c-语言的学习"><a href="#c-语言的学习" class="headerlink" title="c++语言的学习"></a>c++语言的学习</h1><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>通过class定义一种类似于结构体的东西,public表示外部可以调取,private定义内部可以调用.同时可以在内部声明一些函数,函数内部可以在外面完成.</p><h2 id="vector-容器"><a href="#vector-容器" class="headerlink" title="vector 容器"></a>vector 容器</h2><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ol><li><strong>顺序性</strong>:顺序容器的元素是严格线性的,类似于数组</li><li>动态的数组,可以通过指针操作</li><li>可以感知内存的</li></ol><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3>]]></content>
    
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/07/19/hello-world/"/>
    <url>/2023/07/19/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
